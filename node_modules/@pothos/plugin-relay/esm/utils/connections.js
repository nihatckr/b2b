import { decodeBase64, encodeBase64, PothosValidationError } from '@pothos/core';
const OFFSET_CURSOR_PREFIX = "OffsetConnection:";
const DEFAULT_MAX_SIZE = 100;
const DEFAULT_SIZE = 20;
export function offsetForArgs(options) {
    const { before, after, first, last } = options.args;
    var _options_defaultSize;
    const defaultSize = (_options_defaultSize = options.defaultSize) !== null && _options_defaultSize !== void 0 ? _options_defaultSize : DEFAULT_SIZE;
    var _options_maxSize;
    const maxSize = (_options_maxSize = options.maxSize) !== null && _options_maxSize !== void 0 ? _options_maxSize : DEFAULT_MAX_SIZE;
    const beforeOffset = before ? cursorToOffset(before) : Number.POSITIVE_INFINITY;
    const afterOffset = after ? cursorToOffset(after) : 0;
    if (first != null && first < 0) {
        throw new PothosValidationError("Argument \"first\" must be a non-negative integer");
    }
    if (last != null && last < 0) {
        throw new PothosValidationError("Argument \"last\" must be a non-negative integer");
    }
    let startOffset = after ? afterOffset + 1 : 0;
    let endOffset = before ? Math.max(beforeOffset, startOffset) : options.totalCount != null ? Math.max(options.totalCount, 0) : Number.POSITIVE_INFINITY;
    if (first != null) {
        endOffset = Math.min(endOffset, startOffset + first);
    }
    if (last != null) {
        if (endOffset === Number.POSITIVE_INFINITY) {
            throw new PothosValidationError("Argument \"last\" can only be used in combination with \"before\" or \"first\"");
        }
        startOffset = Math.max(startOffset, endOffset - last);
    }
    const size = first == null && last == null ? defaultSize : endOffset - startOffset;
    endOffset = Math.min(endOffset, startOffset + Math.min(size, maxSize));
    const totalSize = endOffset - startOffset;
    return {
        offset: startOffset,
        limit: totalSize + 1,
        hasPreviousPage: startOffset > 0,
        expectedSize: totalSize,
        hasNextPage: (resultSize) => resultSize > totalSize
    };
}
export async function resolveOffsetConnection(options, resolve) {
    const { limit, offset, expectedSize, hasPreviousPage, hasNextPage } = offsetForArgs(options);
    const nodes = await resolve({
        offset,
        limit
    });
    if (!nodes) {
        return nodes;
    }
    const edges = nodes.map((value, index) => value == null ? null : {
        cursor: offsetToCursor(offset + index),
        node: value
    });
    const trimmed = edges.slice(0, expectedSize);
    return {
        edges: trimmed,
        totalCount: options.totalCount,
        pageInfo: {
            startCursor: offsetToCursor(offset),
            endCursor: offsetToCursor(offset + trimmed.length - 1),
            hasPreviousPage,
            hasNextPage: hasNextPage(nodes.length)
        }
    };
}
export function cursorToOffset(cursor) {
    const string = decodeBase64(cursor);
    if (!string.startsWith(OFFSET_CURSOR_PREFIX)) {
        throw new PothosValidationError(`Invalid offset cursor ${OFFSET_CURSOR_PREFIX}`);
    }
    return Number.parseInt(string.slice(OFFSET_CURSOR_PREFIX.length), 10);
}
export function offsetToCursor(offset) {
    return encodeBase64(`${OFFSET_CURSOR_PREFIX}${offset}`);
}
export function resolveArrayConnection(options, array) {
    const { limit, offset, expectedSize, hasPreviousPage, hasNextPage } = offsetForArgs({
        totalCount: array.length,
        ...options
    });
    const nodes = array.slice(offset, offset + limit);
    const edges = nodes.map((value, index) => value == null ? null : {
        cursor: offsetToCursor(offset + index),
        node: value
    });
    const trimmed = edges.slice(0, expectedSize);
    return {
        edges: trimmed,
        totalCount: array.length,
        pageInfo: {
            startCursor: offsetToCursor(offset),
            endCursor: offsetToCursor(offset + trimmed.length - 1),
            hasPreviousPage,
            hasNextPage: hasNextPage(nodes.length)
        }
    };
}
export function parseCursorConnectionArgs(options) {
    const { before, after, first, last } = options.args;
    var _options_defaultSize;
    const defaultSize = (_options_defaultSize = options.defaultSize) !== null && _options_defaultSize !== void 0 ? _options_defaultSize : DEFAULT_SIZE;
    var _options_maxSize;
    const maxSize = (_options_maxSize = options.maxSize) !== null && _options_maxSize !== void 0 ? _options_maxSize : DEFAULT_MAX_SIZE;
    if (first != null && first < 0) {
        throw new PothosValidationError("Argument \"first\" must be a non-negative integer");
    }
    if (last != null && last < 0) {
        throw new PothosValidationError("Argument \"last\" must be a non-negative integer");
    }
    var _ref;
    const limit = Math.min((_ref = first !== null && first !== void 0 ? first : last) !== null && _ref !== void 0 ? _ref : defaultSize, maxSize) + 1;
    const inverted = after ? !!last && !first : !!before && !first || !first && !!last;
    return {
        before: before !== null && before !== void 0 ? before : undefined,
        after: after !== null && after !== void 0 ? after : undefined,
        limit,
        expectedSize: limit - 1,
        inverted,
        hasPreviousPage: (resultSize) => inverted ? resultSize >= limit : !!after,
        hasNextPage: (resultSize) => inverted ? !!before : resultSize >= limit
    };
}
export async function resolveCursorConnection(options, resolve) {
    var _edges_, _edges_1;
    const { before, after, limit, inverted, expectedSize, hasPreviousPage, hasNextPage } = parseCursorConnectionArgs(options);
    const nodes = await resolve({
        before,
        after,
        limit,
        inverted
    });
    if (!nodes) {
        return nodes;
    }
    const trimmed = nodes.slice(0, expectedSize);
    if (inverted) {
        trimmed.reverse();
    }
    const edges = trimmed.map((value) => value == null ? null : {
        cursor: options.toCursor(value, trimmed),
        node: value
    });
    var _options_args_after, _ref;
    const startCursor = edges.length > 0 ? (_edges_ = edges[0]) === null || _edges_ === void 0 ? void 0 : _edges_.cursor : (_ref = (_options_args_after = options.args.after) !== null && _options_args_after !== void 0 ? _options_args_after : options.args.before) !== null && _ref !== void 0 ? _ref : "";
    var _options_args_after1, _ref1;
    const endCursor = edges.length > 0 ? (_edges_1 = edges[edges.length - 1]) === null || _edges_1 === void 0 ? void 0 : _edges_1.cursor : (_ref1 = (_options_args_after1 = options.args.after) !== null && _options_args_after1 !== void 0 ? _options_args_after1 : options.args.before) !== null && _ref1 !== void 0 ? _ref1 : "";
    return {
        edges: edges,
        pageInfo: {
            startCursor,
            endCursor,
            hasPreviousPage: hasPreviousPage(nodes.length),
            hasNextPage: hasNextPage(nodes.length)
        }
    };
}
//# sourceMappingURL=connections.js.map
