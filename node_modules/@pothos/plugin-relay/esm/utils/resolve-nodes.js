import { brandWithType, createContextCache, PothosValidationError } from '@pothos/core';
const getRequestCache = createContextCache(() => new Map());
export async function resolveNodes(builder, context, info, globalIDs) {
    const requestCache = getRequestCache(context);
    const idsByType = {};
    const results = {};
    for (const globalID of globalIDs) {
        if (globalID == null) {
            continue;
        }
        const { id, typename } = globalID;
        const cacheKey = `${typename}:${id}`;
        if (requestCache.has(cacheKey)) {
            results[cacheKey] = requestCache.get(cacheKey);
            continue;
        }
        var _idsByType_typename;
        idsByType[typename] = (_idsByType_typename = idsByType[typename]) !== null && _idsByType_typename !== void 0 ? _idsByType_typename : new Set();
        idsByType[typename].add(id);
    }
    await Promise.all(Object.keys(idsByType).map(async (typename) => {
        var _builder_options_relay;
        const ids = [
            ...idsByType[typename]
        ];
        const config = builder.configStore.getTypeConfig(typename, "Object");
        const options = config.pothosOptions;
        var _options_brandLoadedObjects, _ref;
        const shouldBrandObjects = (_ref = (_options_brandLoadedObjects = options.brandLoadedObjects) !== null && _options_brandLoadedObjects !== void 0 ? _options_brandLoadedObjects : (_builder_options_relay = builder.options.relay) === null || _builder_options_relay === void 0 ? void 0 : _builder_options_relay.brandLoadedObjects) !== null && _ref !== void 0 ? _ref : true;
        const resultsForType = await resolveUncachedNodesForType(builder, context, info, ids, typename);
        resultsForType.forEach((val, i) => {
            if (shouldBrandObjects) {
                brandWithType(val, typename);
            }
            results[`${typename}:${ids[i]}`] = val;
        });
    }));
    return globalIDs.map((globalID) => {
        var _results_;
        return globalID == null ? null : (_results_ = results[`${globalID.typename}:${globalID.id}`]) !== null && _results_ !== void 0 ? _results_ : null;
    });
}
// biome-ignore lint/suspicious/useAwait: ensure that this returns a promise
export async function resolveUncachedNodesForType(builder, context, info, ids, type) {
    const requestCache = getRequestCache(context);
    const config = builder.configStore.getTypeConfig(type, "Object");
    const options = config.pothosOptions;
    if (options.loadMany) {
        const loadManyPromise = Promise.resolve(options.loadMany(ids, context));
        return Promise.all(ids.map((id, i) => {
            const entryPromise = loadManyPromise.then((results) => results[i]).then((result) => {
                requestCache.set(`${config.name}:${id}`, result);
                return result;
            });
            requestCache.set(`${config.name}:${id}`, entryPromise);
            return entryPromise;
        }));
    }
    if (options.loadOne) {
        return Promise.all(ids.map((id) => {
            const entryPromise = Promise.resolve(options.loadOne(id, context)).then((result) => {
                requestCache.set(`${config.name}:${id}`, result);
                return result;
            });
            requestCache.set(`${config.name}:${id}`, entryPromise);
            return entryPromise;
        }));
    }
    if (options.loadManyWithoutCache) {
        return options.loadManyWithoutCache(ids, context);
    }
    if (options.loadWithoutCache) {
        return Promise.all(ids.map((id) => Promise.resolve(options.loadWithoutCache(id, context, info))));
    }
    throw new PothosValidationError(`${config.name} does not support loading by id`);
}
//# sourceMappingURL=resolve-nodes.js.map
