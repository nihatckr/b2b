import { type MaybePromise, type Merge, type SchemaTypes } from '@pothos/core';
import type { ArrayConnectionShape, DefaultConnectionArguments } from '../types.js';
interface ResolveOffsetConnectionOptions {
    args: DefaultConnectionArguments;
    defaultSize?: number;
    maxSize?: number;
    totalCount?: number;
}
export interface ResolveCursorConnectionOptions<T> {
    args: DefaultConnectionArguments;
    defaultSize?: number;
    maxSize?: number;
    toCursor: (value: T, nodes: T[]) => string;
}
export interface ResolveCursorConnectionArgs {
    before?: string;
    after?: string;
    limit: number;
    inverted: boolean;
}
interface ResolveArrayConnectionOptions {
    args: DefaultConnectionArguments;
    defaultSize?: number;
    maxSize?: number;
}
export declare function offsetForArgs(options: ResolveOffsetConnectionOptions): {
    offset: number;
    limit: number;
    hasPreviousPage: boolean;
    expectedSize: number;
    hasNextPage: (resultSize: number) => boolean;
};
export declare function resolveOffsetConnection<T, U extends Promise<readonly T[] | null> | readonly T[] | null, C extends number | undefined = undefined>(options: ResolveOffsetConnectionOptions & {
    totalCount?: C;
}, resolve: (params: {
    offset: number;
    limit: number;
}) => U & (MaybePromise<readonly T[] | null> | null)): Promise<Merge<ArrayConnectionShape<SchemaTypes, NonNullable<T>, U extends NonNullable<U> ? (Promise<null> extends U ? true : false) : true, T extends NonNullable<T> ? false : {
    list: false;
    items: true;
}, false> & {
    totalCount: C;
}>>;
export declare function cursorToOffset(cursor: string): number;
export declare function offsetToCursor(offset: number): string;
export declare function resolveArrayConnection<T>(options: ResolveArrayConnectionOptions, array: readonly T[]): Merge<ArrayConnectionShape<SchemaTypes, NonNullable<T>, false, T extends NonNullable<T> ? false : {
    list: false;
    items: true;
}, false> & {
    totalCount: number;
}>;
export declare function parseCursorConnectionArgs(options: ResolveOffsetConnectionOptions): {
    before: string | undefined;
    after: string | undefined;
    limit: number;
    expectedSize: number;
    inverted: boolean;
    hasPreviousPage: (resultSize: number) => boolean;
    hasNextPage: (resultSize: number) => boolean;
};
type NodeType<T> = T extends (infer N)[] | Promise<(infer N)[] | null> | null ? N : never;
export declare function resolveCursorConnection<U extends Promise<readonly unknown[] | null> | readonly unknown[] | null>(options: ResolveCursorConnectionOptions<NodeType<U>>, resolve: (params: ResolveCursorConnectionArgs) => U): Promise<Merge<ArrayConnectionShape<SchemaTypes, NodeType<U>, false, false, false>>>;
export {};
//# sourceMappingURL=connections.d.ts.map
