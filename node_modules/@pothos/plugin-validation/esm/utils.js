import { completeValue, isThenable } from '@pothos/core';
export function createArgsValidator(argMappings, argsSchemas, options) {
    const argMapper = argMappings ? createInputValueMapper(argMappings, (value, mappings, addIssues) => {
        var _mappings_value;
        if (!((_mappings_value = mappings.value) === null || _mappings_value === void 0 ? void 0 : _mappings_value.typeSchemas.length)) {
            return value;
        }
        return reduceMaybeAsync(mappings.value.typeSchemas, value, (val, schema) => completeValue(schema["~standard"].validate(val), (result) => {
            if (result.issues) {
                addIssues(result.issues);
                return null;
            }
            return result.value;
        }));
    }, (mapped, mappings, addIssues) => {
        var _mappings_value;
        if (!((_mappings_value = mappings.value) === null || _mappings_value === void 0 ? void 0 : _mappings_value.fieldSchemas.length)) {
            return mapped;
        }
        return reduceMaybeAsync(mappings.value.fieldSchemas, mapped, (val, schema) => completeValue(schema["~standard"].validate(val), (result) => {
            if (result.issues) {
                addIssues(result.issues);
                return null;
            }
            return result.value;
        }));
    }) : null;
    return function validateArgs(args, context, info) {
        return completeValue(argMapper ? argMapper(args) : {
            value: args,
            issues: undefined
        }, (mapped) => {
            if (mapped.issues) {
                throw options.validationError(mapped, args, context, info);
            }
            const schemasArray = Array.isArray(argsSchemas) ? argsSchemas : argsSchemas ? [
                argsSchemas
            ] : [];
            if (schemasArray.length === 0) {
                return mapped.value;
            }
            const issues = [];
            const validated = reduceMaybeAsync(schemasArray, mapped.value, (val, schema) => completeValue(schema["~standard"].validate(val), (result) => {
                if (result.issues) {
                    issues.push(...result.issues);
                    return null;
                }
                return result.value;
            }));
            return completeValue(validated, (result) => {
                if (issues.length) {
                    throw options.validationError({
                        issues
                    }, args, context, info);
                }
                return result;
            });
        });
    };
}
export function createInputValueMapper(argMap, mapType, mapField) {
    return function mapObject(obj, map = argMap, path = [], ...args) {
        const mapped = {
            ...obj
        };
        const issues = [];
        function addIssues(path) {
            return (newIssues) => {
                issues.push(...newIssues.map((issue) => {
                    var _issue_path;
                    return {
                        ...issue,
                        path: [
                            ...path,
                            ...(_issue_path = issue.path) !== null && _issue_path !== void 0 ? _issue_path : []
                        ]
                    };
                }));
            };
        }
        const promises = [];
        map.forEach((field, fieldName) => {
            const fieldVal = obj[fieldName];
            const fieldPromises = [];
            if (fieldVal === null || fieldVal === undefined) {
                mapped[fieldName] = fieldVal;
                return;
            }
            if (field.kind === "InputObject" && field.fields.map) {
                if (field.isList) {
                    mapped[fieldName] = mapListValue(fieldVal, field.listDepth, (val, i, newList, indices) => {
                        if (val == null) {
                            return val;
                        }
                        const result = mapObject(val, field.fields.map, [
                            ...path,
                            fieldName,
                            ...indices
                        ], ...args);
                        const promise = completeValue(result, (newVal) => {
                            if (newVal.issues) {
                                issues.push(...newVal.issues);
                            }
                            else {
                                newList[i] = newVal.value;
                            }
                            return newList[i];
                        });
                        if (isThenable(promise)) {
                            fieldPromises.push(promise);
                        }
                        return promise;
                    });
                }
                else {
                    const promise = completeValue(mapObject(fieldVal, field.fields.map, [
                        ...path,
                        fieldName
                    ], ...args), (newVal) => {
                        if (newVal.issues) {
                            issues.push(...newVal.issues);
                        }
                        else {
                            mapped[fieldName] = newVal.value;
                        }
                    });
                    if (isThenable(promise)) {
                        fieldPromises.push(promise);
                    }
                }
            }
            const promise = completeValue(fieldPromises.length ? Promise.all(fieldPromises) : null, () => {
                if (field.value !== null && !issues.length) {
                    if (field.isList) {
                        const list = mapListValue(mapped[fieldName], field.listDepth, (val, i, arr, indices) => {
                            if (val != null) {
                                const result = mapType(val, field, addIssues([
                                    ...path,
                                    fieldName,
                                    ...indices
                                ]), ...args);
                                if (isThenable(result)) {
                                    promises.push(completeValue(result, (newVal) => {
                                        arr[i] = newVal;
                                    }));
                                }
                                return result;
                            }
                            return val;
                        });
                        return completeValue(mapField(list, field, addIssues([
                            ...path,
                            fieldName
                        ]), ...args), (finalVal) => {
                            mapped[fieldName] = finalVal;
                        });
                    }
                    return completeValue(mapType(mapped[fieldName], field, addIssues([
                        ...path,
                        fieldName
                    ]), ...args), (newVal) => completeValue(mapField(newVal, field, addIssues([
                        ...path,
                        fieldName
                    ]), ...args), (newVal) => {
                        mapped[fieldName] = newVal;
                    }));
                }
            });
            if (isThenable(promise)) {
                promises.push(promise);
            }
        });
        return completeValue(promises.length ? Promise.all(promises) : null, () => {
            return issues.length ? {
                issues
            } : {
                value: mapped,
                issues: undefined
            };
        });
    };
}
export function reduceMaybeAsync(items, initialValue, fn) {
    function next(value, i) {
        if (i === items.length) {
            return value;
        }
        return completeValue(fn(value, items[i], i), (result) => {
            return result === null ? null : next(result, i + 1);
        });
    }
    return next(initialValue, 0);
}
function mapListValue(value, listDepth, mapper, currentIndices = []) {
    if (listDepth === 0) {
        throw new Error("List depth must be greater than 0 for mapping");
    }
    if (!Array.isArray(value)) {
        return value;
    }
    const newList = [
        ...value
    ];
    for (let i = 0; i < newList.length; i++) {
        const indices = [
            ...currentIndices,
            i
        ];
        if (listDepth > 1) {
            newList[i] = mapListValue(newList[i], listDepth - 1, mapper, indices);
        }
        else {
            const result = mapper(newList[i], i, newList, indices);
            if (result !== undefined) {
                newList[i] = result;
            }
        }
    }
    return newList;
}
//# sourceMappingURL=utils.js.map
