"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "PrismaObjectFieldBuilder", {
    enumerable: true,
    get: function() {
        return PrismaObjectFieldBuilder;
    }
});
const _core = require("@pothos/core");
const _graphql = require("graphql");
const _modelloader = require("./model-loader");
const _cursors = require("./util/cursors");
const _datamodel = require("./util/datamodel");
const _description = require("./util/description");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// Workaround for FieldKind not being extended on Builder classes
const RootBuilder = _core.RootFieldBuilder;
class PrismaObjectFieldBuilder extends RootBuilder {
    relation(name, ...allArgs) {
        const [{ description, ...options } = {}] = allArgs;
        const relationField = (0, _datamodel.getRelation)(this.model, this.builder, name);
        var _options_type;
        const ref = (_options_type = options.type) !== null && _options_type !== void 0 ? _options_type : (0, _datamodel.getRefFromModel)(relationField.type, this.builder);
        const { query = {}, resolve, extensions, onNull, ...rest } = options;
        const relationSelect = (_args, _context, nestedQuery)=>({
                select: {
                    [name]: nestedQuery(query)
                }
            });
        return this.field({
            ...rest,
            type: relationField.isList ? [
                ref
            ] : ref,
            description: (0, _description.getFieldDescription)(this.model, this.builder, name, description),
            extensions: {
                ...extensions,
                pothosPrismaSelect: relationSelect,
                pothosPrismaLoaded: (value)=>value[name] !== undefined,
                pothosPrismaFallback: resolve && ((q, parent, args, context, info)=>resolve({
                        ...q,
                        ...typeof query === 'function' ? query(args, context) : query
                    }, parent, args, context, info))
            },
            resolve: (parent)=>{
                const result = parent[name];
                if (typeof onNull === 'function' && result == null) {
                    return onNull(parent, {}, {}, {});
                }
                return result;
            }
        });
    }
    relationCount(name, ...allArgs) {
        const [{ where, ...options } = {}] = allArgs;
        const countSelect = typeof where === 'function' ? (args, context)=>({
                _count: {
                    select: {
                        [name]: {
                            where: where(args, context)
                        }
                    }
                }
            }) : {
            _count: {
                select: {
                    [name]: where ? {
                        where
                    } : true
                }
            }
        };
        return this.field({
            ...options,
            type: 'Int',
            nullable: false,
            select: countSelect,
            resolve: (parent, _args, _context, _info)=>{
                var _parent__count;
                return (_parent__count = parent._count) === null || _parent__count === void 0 ? void 0 : _parent__count[name];
            }
        });
    }
    variant(variant, ...allArgs) {
        const [{ isNull, nullable, ...options } = {}] = allArgs;
        const ref = typeof variant === 'string' ? (0, _datamodel.getRefFromModel)(variant, this.builder) : variant;
        const selfSelect = (_args, _context, nestedQuery)=>nestedQuery({});
        return this.field({
            ...options,
            type: ref,
            extensions: {
                ...options === null || options === void 0 ? void 0 : options.extensions,
                pothosPrismaSelect: selfSelect
            },
            nullable: nullable !== null && nullable !== void 0 ? nullable : !!isNull,
            resolve: isNull ? (parent, args, context, info)=>{
                const parentIsNull = isNull(parent, args, context, info);
                if (parentIsNull) {
                    if ((0, _core.isThenable)(parentIsNull)) {
                        return parentIsNull.then((resolved)=>resolved ? null : parent);
                    }
                    return null;
                }
                return parent;
            } : (parent)=>parent
        });
    }
    expose(name, ...args) {
        var _typeConfig_extensions;
        const [options = {}] = args;
        const typeConfig = this.builder.configStore.getTypeConfig(this.typename);
        const usingSelect = !!((_typeConfig_extensions = typeConfig.extensions) === null || _typeConfig_extensions === void 0 ? void 0 : _typeConfig_extensions.pothosPrismaSelect);
        return this.exposeField(name, {
            ...options,
            description: (0, _description.getFieldDescription)(this.model, this.builder, name, options.description),
            extensions: {
                ...options.extensions,
                pothosPrismaVariant: name,
                pothosPrismaSelect: usingSelect && {
                    [name]: true
                }
            }
        });
    }
    createExpose(type) {
        return (name, ...args)=>{
            const [options = {}] = args;
            return this.expose(name, {
                ...options,
                type
            });
        };
    }
    constructor(typename, builder, model, fieldMap, graphqlKind = 'Object'){
        super(builder, 'PrismaObject', graphqlKind), _define_property(this, "model", void 0), _define_property(this, "prismaFieldMap", void 0), _define_property(this, "exposeBoolean", this.createExpose('Boolean')), _define_property(this, "exposeFloat", this.createExpose('Float')), _define_property(this, "exposeInt", this.createExpose('Int')), _define_property(this, "exposeID", this.createExpose('ID')), _define_property(this, "exposeString", this.createExpose('String')), _define_property(this, "exposeBooleanList", this.createExpose([
            'Boolean'
        ])), _define_property(this, "exposeFloatList", this.createExpose([
            'Float'
        ])), _define_property(this, "exposeIntList", this.createExpose([
            'Int'
        ])), _define_property(this, "exposeIDList", this.createExpose([
            'ID'
        ])), _define_property(this, "exposeStringList", this.createExpose([
            'String'
        ])), _define_property(this, "withAuth", withAuth), _define_property(this, "relatedConnection", function relatedConnection(name, { maxSize = this.builder.options.prisma.maxConnectionSize, defaultSize = this.builder.options.prisma.defaultConnectionSize, cursor: cursorValue, query, resolve, extensions, totalCount, description, ...options }, connectionOptions = {}, edgeOptions = {}) {
            const relationField = (0, _datamodel.getRelation)(this.model, this.builder, name);
            var _options_type;
            const ref = (_options_type = options.type) !== null && _options_type !== void 0 ? _options_type : (0, _datamodel.getRefFromModel)(relationField.type, this.builder);
            let typeName;
            const formatCursor = (0, _cursors.getCursorFormatter)(relationField.type, this.builder, cursorValue);
            const parseCursor = (0, _cursors.getCursorParser)(relationField.type, this.builder, cursorValue);
            const getQuery = (args, ctx)=>{
                const connectionQuery = (0, _cursors.prismaCursorConnectionQuery)({
                    parseCursor,
                    ctx,
                    maxSize,
                    defaultSize,
                    args
                });
                var _ref;
                const { take = connectionQuery.take, skip = connectionQuery.skip, cursor = connectionQuery.cursor, ...fieldQuery } = (_ref = typeof query === 'function' ? query(args, ctx) : query) !== null && _ref !== void 0 ? _ref : {};
                return {
                    ...fieldQuery,
                    ...connectionQuery,
                    take,
                    skip,
                    ...cursor ? {
                        cursor
                    } : {}
                };
            };
            const cursorSelection = _modelloader.ModelLoader.getCursorSelection(ref, relationField.type, cursorValue, this.builder);
            const relationSelect = (args, context, nestedQuery, getSelection)=>{
                var _selection_selectionSet;
                typeName !== null && typeName !== void 0 ? typeName : typeName = this.builder.configStore.getTypeConfig(ref).name;
                const nested = nestedQuery(getQuery(args, context), {
                    getType: ()=>typeName,
                    paths: [
                        [
                            {
                                name: 'nodes'
                            }
                        ],
                        [
                            {
                                name: 'edges'
                            },
                            {
                                name: 'node'
                            }
                        ]
                    ]
                });
                const selection = getSelection([]);
                const hasTotalCount = totalCount && !!getSelection([
                    'totalCount'
                ]);
                const selections = (_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === void 0 ? void 0 : _selection_selectionSet.selections.filter((sel)=>!(sel.kind === _graphql.Kind.FIELD && sel.name.value === '__typename'));
                const totalCountOnly = (selections === null || selections === void 0 ? void 0 : selections.length) === 1 && selections[0].kind === _graphql.Kind.FIELD && selections[0].name.value === 'totalCount' && hasTotalCount;
                const countSelect = this.builder.options.prisma.filterConnectionTotalCount !== false ? nested.where ? {
                    where: nested.where
                } : true : true;
                return {
                    select: {
                        ...hasTotalCount ? {
                            _count: {
                                select: {
                                    [name]: countSelect
                                }
                            }
                        } : {},
                        [name]: totalCountOnly ? undefined : (nested === null || nested === void 0 ? void 0 : nested.select) ? {
                            ...nested,
                            select: {
                                ...cursorSelection,
                                ...nested.select
                            }
                        } : nested
                    }
                };
            };
            const fieldRef = this.connection({
                ...options,
                description: (0, _description.getFieldDescription)(this.model, this.builder, name, description),
                extensions: {
                    ...extensions,
                    pothosPrismaSelect: relationSelect,
                    pothosPrismaLoaded: (value, info)=>{
                        const returnType = (0, _graphql.getNamedType)(info.returnType);
                        const fields = (0, _graphql.isObjectType)(returnType) || (0, _graphql.isInterfaceType)(returnType) ? returnType.getFields() : {};
                        const selections = info.fieldNodes;
                        const totalCountOnly = selections.every((selection)=>{
                            var _selection_selectionSet;
                            return (_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === void 0 ? void 0 : _selection_selectionSet.selections.every((s)=>{
                                var _fields_s_name_value_extensions, _fields_s_name_value;
                                return s.kind === _graphql.Kind.FIELD && (((_fields_s_name_value = fields[s.name.value]) === null || _fields_s_name_value === void 0 ? void 0 : (_fields_s_name_value_extensions = _fields_s_name_value.extensions) === null || _fields_s_name_value_extensions === void 0 ? void 0 : _fields_s_name_value_extensions.pothosPrismaTotalCount) || s.name.value === '__typename');
                            });
                        });
                        return totalCountOnly || value[name] !== undefined;
                    },
                    pothosPrismaFallback: resolve && ((q, parent, args, context, info)=>Promise.resolve(resolve({
                            ...q,
                            ...getQuery(args, context)
                        }, parent, args, context, info)).then((result)=>(0, _cursors.wrapConnectionResult)(parent, result, args, q.take, formatCursor)))
                },
                type: ref,
                resolve: (parent, args, context)=>{
                    var _parent__count;
                    const connectionQuery = getQuery(args, context);
                    var _parent_name;
                    return (0, _cursors.wrapConnectionResult)(parent, (_parent_name = parent[name]) !== null && _parent_name !== void 0 ? _parent_name : [], args, connectionQuery.take, formatCursor, (_parent__count = parent._count) === null || _parent__count === void 0 ? void 0 : _parent__count[name]);
                }
            }, connectionOptions instanceof _core.ObjectRef ? connectionOptions : {
                ...connectionOptions,
                fields: totalCount ? (t)=>{
                    var _connectionOptions_fields;
                    return {
                        totalCount: t.int({
                            nullable: false,
                            extensions: {
                                pothosPrismaTotalCount: true
                            },
                            resolve: (parent, _args, _context)=>parent.totalCount
                        }),
                        ...(_connectionOptions_fields = connectionOptions.fields) === null || _connectionOptions_fields === void 0 ? void 0 : _connectionOptions_fields.call(connectionOptions, t)
                    };
                } : connectionOptions.fields
            }, edgeOptions);
            return fieldRef;
        }), _define_property(this, "typename", void 0);
        this.model = model;
        this.prismaFieldMap = fieldMap;
        this.typename = typename;
        this.builder = builder;
    }
}
function addScopes(scopes, builder) {
    const originalCreateField = builder.createField;
    builder.createField = function createField(options) {
        return originalCreateField.call(this, {
            authScopes: scopes,
            ...options
        });
    };
    return builder;
}
function withAuth(scopes) {
    return addScopes(scopes, new PrismaObjectFieldBuilder(this.typename, this.builder, this.model, this.prismaFieldMap));
}

//# sourceMappingURL=prisma-field-builder.js.map