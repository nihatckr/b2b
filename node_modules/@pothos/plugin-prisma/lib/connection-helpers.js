"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get prismaConnectionHelpers () {
        return prismaConnectionHelpers;
    },
    get prismaModelKey () {
        return prismaModelKey;
    }
});
const _modelloader = require("./model-loader");
const _cursors = require("./util/cursors");
const _datamodel = require("./util/datamodel");
const _getclient = require("./util/get-client");
const _relationmap = require("./util/relation-map");
const _selections = require("./util/selections");
var _builder_options_prisma, _builder_options_prisma1;
const prismaModelKey = Symbol.for('Pothos.prismaModelKey');
function prismaConnectionHelpers(builder, refOrType, { cursor, select, resolveNode, query, args: createArgs, maxSize = (_builder_options_prisma = builder.options.prisma) === null || _builder_options_prisma === void 0 ? void 0 : _builder_options_prisma.maxConnectionSize, defaultSize = (_builder_options_prisma1 = builder.options.prisma) === null || _builder_options_prisma1 === void 0 ? void 0 : _builder_options_prisma1.defaultConnectionSize }) {
    const modelName = typeof refOrType === 'string' ? refOrType : refOrType.modelName;
    const ref = typeof refOrType === 'string' ? (0, _datamodel.getRefFromModel)(modelName, builder) : refOrType;
    const formatCursor = (0, _cursors.getCursorFormatter)(modelName, builder, cursor);
    const parseCursor = (0, _cursors.getCursorParser)(modelName, builder, cursor);
    const cursorSelection = _modelloader.ModelLoader.getCursorSelection(ref, modelName, cursor, builder);
    const fieldMap = (0, _relationmap.getRelationMap)((0, _getclient.getDMMF)(builder)).get(modelName);
    function resolve(list, args, ctx, parent) {
        return (0, _cursors.wrapConnectionResult)(parent, list, args, getQueryArgs(args, ctx).take, formatCursor, null, resolveNode !== null && resolveNode !== void 0 ? resolveNode : (edge)=>edge);
    }
    function getQueryArgs(args, ctx) {
        return (0, _cursors.prismaCursorConnectionQuery)({
            args,
            ctx,
            maxSize: typeof maxSize === 'function' ? maxSize(args, ctx) : maxSize,
            defaultSize: typeof defaultSize === 'function' ? defaultSize(args, ctx) : defaultSize,
            parseCursor
        });
    }
    function getQuery(args, ctx, nestedSelection) {
        const nestedSelect = select ? {
            select: select((sel)=>nestedSelection(sel, [
                    'edges',
                    'node'
                ]), args, ctx)
        } : nestedSelection(true, [
            'edges',
            'node'
        ]);
        var _builder_options_prisma_skipDeferredFragments;
        const selectState = (0, _selections.createState)(fieldMap, 'select', (_builder_options_prisma_skipDeferredFragments = builder.options.prisma.skipDeferredFragments) !== null && _builder_options_prisma_skipDeferredFragments !== void 0 ? _builder_options_prisma_skipDeferredFragments : true);
        (0, _selections.mergeSelection)(selectState, {
            select: cursorSelection
        });
        if (typeof nestedSelect === 'object' && nestedSelect) {
            (0, _selections.mergeSelection)(selectState, nestedSelect);
        }
        const baseQuery = typeof query === 'function' ? query(args, ctx) : query !== null && query !== void 0 ? query : {};
        return {
            ...baseQuery,
            ...getQueryArgs(args, ctx),
            ...(0, _selections.selectionToQuery)(selectState)
        };
    }
    const getArgs = ()=>createArgs ? builder.args(createArgs) : {};
    return {
        ref: typeof refOrType === 'string' ? (0, _datamodel.getRefFromModel)(refOrType, builder) : refOrType,
        resolve,
        select: select !== null && select !== void 0 ? select : {},
        getQuery,
        getArgs
    };
}

//# sourceMappingURL=connection-helpers.js.map