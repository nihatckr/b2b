"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get getIndirectType () {
        return getIndirectType;
    },
    get queryFromInfo () {
        return queryFromInfo;
    },
    get selectionStateFromInfo () {
        return selectionStateFromInfo;
    }
});
const _core = require("@pothos/core");
const _graphql = require("graphql");
const _loadermap = require("./loader-map");
const _selections = require("./selections");
const _usage = require("./usage");
function addTypeSelectionsForField(type, context, info, state, selection, indirectPath, deferred) {
    if (selection.name.value.startsWith('__')) {
        return;
    }
    var _type_extensions;
    const { pothosPrismaInclude, pothosPrismaSelect, pothosIndirectInclude, pothosPrismaModel } = (_type_extensions = type.extensions) !== null && _type_extensions !== void 0 ? _type_extensions : {};
    if (!!(pothosIndirectInclude === null || pothosIndirectInclude === void 0 ? void 0 : pothosIndirectInclude.path) && pothosIndirectInclude.path.length > 0 || !!(pothosIndirectInclude === null || pothosIndirectInclude === void 0 ? void 0 : pothosIndirectInclude.paths) && pothosIndirectInclude.paths.length === 0) {
        var _pothosIndirectInclude_paths;
        resolveIndirectIncludePaths(type, info, selection, [], (_pothosIndirectInclude_paths = pothosIndirectInclude.paths) !== null && _pothosIndirectInclude_paths !== void 0 ? _pothosIndirectInclude_paths : [
            pothosIndirectInclude.path
        ], indirectPath, (resolvedType, field, path, deferred)=>{
            addTypeSelectionsForField(resolvedType, context, info, state, field, path, deferred);
        });
    } else if (pothosIndirectInclude) {
        addTypeSelectionsForField(info.schema.getType(pothosIndirectInclude.getType()), context, info, state, selection, indirectPath, deferred);
        return;
    }
    if (!((0, _graphql.isObjectType)(type) || (0, _graphql.isInterfaceType)(type))) {
        return;
    }
    if (pothosPrismaModel && !pothosPrismaSelect) {
        state.mode = 'include';
    }
    if (pothosPrismaInclude !== null && pothosPrismaInclude !== void 0 ? pothosPrismaInclude : pothosPrismaSelect) {
        (0, _selections.mergeSelection)(state, {
            select: pothosPrismaSelect ? {
                ...pothosPrismaSelect
            } : undefined,
            include: pothosPrismaInclude ? {
                ...pothosPrismaInclude
            } : undefined
        });
    }
    if (selection.selectionSet && (!deferred || !state.skipDeferredFragments)) {
        addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
    }
}
function resolveIndirectIncludePaths(type, info, selection, pathPrefix, includePaths, path, resolve, deferred = false) {
    for (const includePath of includePaths){
        if (pathPrefix.length > 0) {
            resolveIndirectInclude(type, info, selection, [
                ...pathPrefix,
                ...includePath
            ], path, resolve, deferred);
        } else {
            resolveIndirectInclude(type, info, selection, includePath, path, resolve, deferred);
        }
    }
}
function resolveIndirectInclude(type, info, selection, includePath, path, resolve, deferred = false, expectedType = type) {
    if (includePath.length === 0) {
        resolve(type, selection, path, deferred);
        return;
    }
    const [include, ...rest] = includePath;
    if (!selection.selectionSet || !include) {
        return;
    }
    for (const sel of selection.selectionSet.selections){
        switch(sel.kind){
            case _graphql.Kind.FIELD:
                if (expectedType.name === type.name && !fieldSkipped(info, sel) && sel.name.value === include.name && ((0, _graphql.isObjectType)(type) || (0, _graphql.isInterfaceType)(type))) {
                    var _sel_alias;
                    const returnType = (0, _graphql.getNamedType)(type.getFields()[sel.name.value].type);
                    var _sel_alias_value;
                    resolveIndirectInclude(returnType, info, sel, rest, [
                        ...path,
                        (_sel_alias_value = (_sel_alias = sel.alias) === null || _sel_alias === void 0 ? void 0 : _sel_alias.value) !== null && _sel_alias_value !== void 0 ? _sel_alias_value : sel.name.value
                    ], resolve, deferred);
                }
                continue;
            case _graphql.Kind.FRAGMENT_SPREAD:
                resolveIndirectInclude(info.schema.getType(info.fragments[sel.name.value].typeCondition.name.value), info, info.fragments[sel.name.value], includePath, path, resolve, deferred || isDeferredFragment(sel, info), include.type ? info.schema.getType(include.type) : expectedType);
                continue;
            case _graphql.Kind.INLINE_FRAGMENT:
                if (!sel.typeCondition || !include.type || sel.typeCondition.name.value === include.type) {
                    resolveIndirectInclude(sel.typeCondition ? info.schema.getType(sel.typeCondition.name.value) : type, info, sel, includePath, path, resolve, deferred || isDeferredFragment(sel, info), include.type ? info.schema.getType(include.type) : expectedType);
                }
                continue;
            default:
                throw new _core.PothosValidationError(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addNestedSelections(type, context, info, state, selections, indirectPath, expectedType = type) {
    let parentType = type;
    for (const selection of selections.selections){
        switch(selection.kind){
            case _graphql.Kind.FIELD:
                if (expectedType.name !== type.name) {
                    continue;
                }
                addFieldSelection(type, context, info, state, selection, indirectPath);
                continue;
            case _graphql.Kind.FRAGMENT_SPREAD:
                var _parentType_extensions;
                if (state.skipDeferredFragments && isDeferredFragment(selection, info)) {
                    continue;
                }
                parentType = info.schema.getType(info.fragments[selection.name.value].typeCondition.name.value);
                addNestedSelections(parentType, context, info, state, info.fragments[selection.name.value].selectionSet, indirectPath, ((_parentType_extensions = parentType.extensions) === null || _parentType_extensions === void 0 ? void 0 : _parentType_extensions.pothosPrismaModel) === type.extensions.pothosPrismaModel ? parentType : expectedType);
                continue;
            case _graphql.Kind.INLINE_FRAGMENT:
                var _parentType_extensions1;
                if (state.skipDeferredFragments && isDeferredFragment(selection, info)) {
                    continue;
                }
                parentType = selection.typeCondition ? info.schema.getType(selection.typeCondition.name.value) : type;
                addNestedSelections(parentType, context, info, state, selection.selectionSet, indirectPath, ((_parentType_extensions1 = parentType.extensions) === null || _parentType_extensions1 === void 0 ? void 0 : _parentType_extensions1.pothosPrismaModel) === type.extensions.pothosPrismaModel ? parentType : expectedType);
                continue;
            default:
                throw new _core.PothosValidationError(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addFieldSelection(type, context, info, state, selection, indirectPath) {
    var _field_extensions;
    if (selection.name.value.startsWith('__') || fieldSkipped(info, selection)) {
        return;
    }
    const field = type.getFields()[selection.name.value];
    if (!field) {
        throw new _core.PothosValidationError(`Unknown field ${selection.name.value} on ${type.name}`);
    }
    const fieldSelect = (_field_extensions = field.extensions) === null || _field_extensions === void 0 ? void 0 : _field_extensions.pothosPrismaSelect;
    let fieldSelectionMap;
    let mappings = {};
    if (typeof fieldSelect === 'function') {
        const args = (0, _core.getMappedArgumentValues)(field, selection, context, info);
        fieldSelectionMap = fieldSelect(args, context, (rawQuery, indirectInclude, expectedType)=>{
            const returnType = (0, _graphql.getNamedType)(field.type);
            const query = typeof rawQuery === 'function' ? rawQuery(args, context) : rawQuery;
            const normalizedIndirectInclude = Array.isArray(indirectInclude) ? normalizeInclude(indirectInclude, getIndirectType(returnType, info), expectedType ? (0, _graphql.getNamedType)(info.schema.getType(expectedType)) : undefined) : indirectInclude;
            const fieldState = createStateForType(getIndirectType(normalizedIndirectInclude ? info.schema.getType(normalizedIndirectInclude.getType()) : returnType, info), info, state.skipDeferredFragments, state);
            if (typeof query === 'object' && Object.keys(query).length > 0) {
                (0, _selections.mergeSelection)(fieldState, {
                    select: {},
                    ...query
                });
            }
            if (!!(normalizedIndirectInclude === null || normalizedIndirectInclude === void 0 ? void 0 : normalizedIndirectInclude.path) && normalizedIndirectInclude.path.length > 0 || !!(normalizedIndirectInclude === null || normalizedIndirectInclude === void 0 ? void 0 : normalizedIndirectInclude.paths) && normalizedIndirectInclude.paths.length > 0) {
                var _returnType_extensions_pothosIndirectInclude, _returnType_extensions;
                var _returnType_extensions_pothosIndirectInclude_path, _normalizedIndirectInclude_paths;
                resolveIndirectIncludePaths(returnType, info, selection, (_returnType_extensions_pothosIndirectInclude_path = (_returnType_extensions = returnType.extensions) === null || _returnType_extensions === void 0 ? void 0 : (_returnType_extensions_pothosIndirectInclude = _returnType_extensions.pothosIndirectInclude) === null || _returnType_extensions_pothosIndirectInclude === void 0 ? void 0 : _returnType_extensions_pothosIndirectInclude.path) !== null && _returnType_extensions_pothosIndirectInclude_path !== void 0 ? _returnType_extensions_pothosIndirectInclude_path : [], (_normalizedIndirectInclude_paths = normalizedIndirectInclude === null || normalizedIndirectInclude === void 0 ? void 0 : normalizedIndirectInclude.paths) !== null && _normalizedIndirectInclude_paths !== void 0 ? _normalizedIndirectInclude_paths : (normalizedIndirectInclude === null || normalizedIndirectInclude === void 0 ? void 0 : normalizedIndirectInclude.path) ? [
                    normalizedIndirectInclude.path
                ] : [], [], (resolvedType, resolvedField, path, deferred)=>{
                    addTypeSelectionsForField(resolvedType, context, info, fieldState, resolvedField, path, deferred);
                });
            } else if (normalizedIndirectInclude) {
                const targetType = info.schema.getType(normalizedIndirectInclude.getType());
                if (targetType !== returnType) {
                    addTypeSelectionsForField(targetType, context, info, fieldState, selection, []);
                }
            }
            addTypeSelectionsForField(returnType, context, info, fieldState, selection, []);
            mappings = fieldState.mappings;
            return (0, _selections.selectionToQuery)(fieldState);
        }, (path)=>{
            if (path.length === 0) {
                return selection;
            }
            const returnType = (0, _graphql.getNamedType)(field.type);
            let node = null;
            resolveIndirectInclude(returnType, info, selection, path.map((name)=>({
                    name
                })), [], (_, resolvedField)=>{
                node = resolvedField;
            });
            return node;
        });
    } else {
        fieldSelectionMap = {
            select: fieldSelect
        };
    }
    if (fieldSelect && (0, _selections.selectionCompatible)(state, fieldSelectionMap, true)) {
        var _selection_alias;
        (0, _selections.mergeSelection)(state, fieldSelectionMap);
        var _selection_alias_value;
        state.mappings[(_selection_alias_value = (_selection_alias = selection.alias) === null || _selection_alias === void 0 ? void 0 : _selection_alias.value) !== null && _selection_alias_value !== void 0 ? _selection_alias_value : selection.name.value] = {
            field: selection.name.value,
            type: type.name,
            mappings,
            indirectPath
        };
    }
}
function queryFromInfo({ context, info, typeName, select, include, path = [], paths = [], withUsageCheck = false, skipDeferredFragments = true }) {
    const returnType = (0, _graphql.getNamedType)(info.returnType);
    const type = typeName ? info.schema.getTypeMap()[typeName] : returnType;
    let state;
    const initialSelection = select ? {
        select
    } : include ? {
        include
    } : undefined;
    if (path.length > 0 || paths.length > 0) {
        var _returnType_extensions;
        const { pothosIndirectInclude } = (_returnType_extensions = returnType.extensions) !== null && _returnType_extensions !== void 0 ? _returnType_extensions : {};
        var _pothosIndirectInclude_path;
        resolveIndirectInclude(returnType, info, info.fieldNodes[0], (_pothosIndirectInclude_path = pothosIndirectInclude === null || pothosIndirectInclude === void 0 ? void 0 : pothosIndirectInclude.path) !== null && _pothosIndirectInclude_path !== void 0 ? _pothosIndirectInclude_path : [], [], (indirectType, indirectField, subPath, deferred)=>{
            resolveIndirectIncludePaths(indirectType, info, indirectField, [], paths.length > 0 ? paths.map((p)=>p.map((n)=>typeof n === 'string' ? {
                        name: n
                    } : n)) : [
                path.map((n)=>typeof n === 'string' ? {
                        name: n
                    } : n)
            ], subPath, (resolvedType, resolvedField, nested, deferred)=>{
                state = createStateForType(typeName ? type : resolvedType, info, skipDeferredFragments, undefined, initialSelection);
                addTypeSelectionsForField(typeName ? type : resolvedType, context, info, state, resolvedField, nested, deferred);
            }, deferred);
        });
    } else {
        state = createStateForType(type, info, skipDeferredFragments, undefined, initialSelection);
        addTypeSelectionsForField(type, context, info, state, info.fieldNodes[0], []);
    }
    if (!state) {
        state = createStateForType(type, info, skipDeferredFragments, undefined, initialSelection);
    }
    (0, _loadermap.setLoaderMappings)(context, info, state.mappings);
    const query = (0, _selections.selectionToQuery)(state);
    return withUsageCheck ? (0, _usage.wrapWithUsageCheck)(query) : query;
}
function selectionStateFromInfo(context, info, skipDeferredFragments, typeName) {
    const type = typeName ? info.schema.getTypeMap()[typeName] : info.parentType;
    const state = createStateForType(type, info, skipDeferredFragments);
    if (!((0, _graphql.isObjectType)(type) || (0, _graphql.isInterfaceType)(type))) {
        throw new _core.PothosValidationError('Prisma plugin can only resolve includes for object and interface types');
    }
    addFieldSelection(type, context, info, state, info.fieldNodes[0], []);
    return state;
}
function createStateForType(type, info, skipDeferredFragments, parent, initialSelections) {
    var _targetType_extensions, _targetType_extensions1;
    const targetType = getIndirectType(type, info);
    const fieldMap = (_targetType_extensions = targetType.extensions) === null || _targetType_extensions === void 0 ? void 0 : _targetType_extensions.pothosPrismaFieldMap;
    const state = (0, _selections.createState)(fieldMap, ((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === void 0 ? void 0 : _targetType_extensions1.pothosPrismaSelect) ? 'select' : 'include', skipDeferredFragments, parent);
    if (initialSelections) {
        (0, _selections.mergeSelection)(state, initialSelections);
    }
    return state;
}
function getIndirectType(type, info) {
    var _targetType_extensions;
    let targetType = type;
    while((_targetType_extensions = targetType.extensions) === null || _targetType_extensions === void 0 ? void 0 : _targetType_extensions.pothosIndirectInclude){
        var _targetType_extensions1;
        targetType = info.schema.getType(((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === void 0 ? void 0 : _targetType_extensions1.pothosIndirectInclude).getType());
    }
    return targetType;
}
function normalizeInclude(path, type, expectedType) {
    let currentType = path.length > 0 ? type : expectedType !== null && expectedType !== void 0 ? expectedType : type;
    const normalized = [];
    if (!((0, _graphql.isObjectType)(currentType) || (0, _graphql.isInterfaceType)(currentType))) {
        throw new _core.PothosValidationError(`Expected ${currentType} to be an Object type`);
    }
    for (const fieldName of path){
        const field = currentType.getFields()[fieldName];
        if (!field) {
            throw new _core.PothosValidationError(`Expected ${currentType} to have a field ${fieldName}`);
        }
        currentType = (0, _graphql.getNamedType)(field.type);
        if (!((0, _graphql.isObjectType)(currentType) || (0, _graphql.isInterfaceType)(currentType))) {
            throw new _core.PothosValidationError(`Expected ${currentType} to be an Object or Interface type`);
        }
        normalized.push({
            name: fieldName,
            type: currentType.name
        });
    }
    return {
        getType: ()=>{
            var _expectedType_name;
            return (_expectedType_name = expectedType === null || expectedType === void 0 ? void 0 : expectedType.name) !== null && _expectedType_name !== void 0 ? _expectedType_name : normalized.length > 0 ? normalized[normalized.length - 1].type : type.name;
        },
        path: normalized
    };
}
function fieldSkipped(info, selection) {
    const skip = (0, _graphql.getDirectiveValues)(_graphql.GraphQLSkipDirective, selection, info.variableValues);
    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return true;
    }
    const include = (0, _graphql.getDirectiveValues)(_graphql.GraphQLIncludeDirective, selection, info.variableValues);
    if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return true;
    }
    return false;
}
function isDeferredFragment(node, info) {
    const deferDirective = info.schema.getDirective('defer');
    if (!deferDirective) {
        return false;
    }
    const defer = (0, _graphql.getDirectiveValues)(deferDirective, node, info.variableValues);
    return !!defer && defer.if !== false;
}

//# sourceMappingURL=map-query.js.map