"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get createState () {
        return createState;
    },
    get mergeSelection () {
        return mergeSelection;
    },
    get mergeState () {
        return mergeState;
    },
    get selectionCompatible () {
        return selectionCompatible;
    },
    get selectionToQuery () {
        return selectionToQuery;
    },
    get stateCompatible () {
        return stateCompatible;
    }
});
const _deepequal = require("./deep-equal");
function selectionCompatible(state, selectionMap, ignoreQuery = false) {
    if (typeof selectionMap === 'boolean') {
        return ignoreQuery || !selectionMap || Object.keys(state.query).length === 0;
    }
    const { select, include, ...query } = selectionMap;
    if (select && Object.keys(select).some((key)=>compare(key, select[key]))) {
        return false;
    }
    if (include && Object.keys(include).some((key)=>compare(key, include[key]))) {
        return false;
    }
    return ignoreQuery || (0, _deepequal.deepEqual)(state.query, query);
    function compare(key, value) {
        if (key === '_count') {
            const selections = value && value.select;
            const keys = selections && Object.keys(selections);
            if (!keys || keys.length === 0) {
                return false;
            }
            return keys.some((k)=>state.counts.has(k) && !(0, _deepequal.deepEqual)(state.counts.get(k), selections[k]));
        }
        return value && state.fieldMap.relations.has(key) && state.relations.has(key) && !selectionCompatible(state.relations.get(key), value);
    }
}
function stateCompatible(state, newState, ignoreQuery = false) {
    for (const [name, relationState] of newState.relations){
        if (state.relations.has(name) && !stateCompatible(state.relations.get(name), relationState)) {
            return false;
        }
    }
    return ignoreQuery || (0, _deepequal.deepEqual)(state.query, newState.query);
}
function mergeState(state, newState) {
    for (const [name, relationState] of newState.relations){
        if (state.relations.has(name)) {
            mergeState(state.relations.get(name), relationState);
        }
    }
    if (newState.mode === 'include') {
        state.mode = 'include';
    } else {
        for (const name of newState.fields){
            state.fields.add(name);
        }
    }
}
function createState(fieldMap, mode, skipDeferredFragments, parent) {
    return {
        parent,
        mode,
        fieldMap,
        query: {},
        fields: new Set(),
        counts: new Map(),
        relations: new Map(),
        mappings: {},
        skipDeferredFragments
    };
}
function mergeSelection(state, { select, include, ...query }) {
    if (state.mode === 'select' && !select) {
        state.mode = 'include';
    }
    if (include) {
        for (const key of Object.keys(include)){
            merge(key, include[key]);
        }
    }
    if (select) {
        for (const key of Object.keys(select)){
            merge(key, select[key]);
        }
    }
    if (Object.keys(query).length > 0) {
        state.query = query;
    }
    function merge(key, value) {
        if (!value) {
            return;
        }
        if (key === '_count') {
            var _value_select;
            const counts = (_value_select = value.select) !== null && _value_select !== void 0 ? _value_select : {};
            for (const count of Object.keys(counts)){
                state.counts.set(count, counts[count]);
            }
            return;
        }
        const selection = value === true ? {
            include: {}
        } : value;
        const childMap = state.fieldMap.relations.get(key);
        if (childMap) {
            if (state.relations.has(key)) {
                mergeSelection(state.relations.get(key), selection);
            } else {
                const relatedState = createState(childMap, 'select', state.skipDeferredFragments);
                mergeSelection(relatedState, selection);
                state.relations.set(key, relatedState);
            }
        } else {
            state.fields.add(key);
        }
    }
}
function selectionToQuery(state) {
    const nestedIncludes = {};
    const counts = {};
    let hasSelection = false;
    state.relations.forEach((sel, relation)=>{
        hasSelection = true;
        const nested = selectionToQuery(sel);
        nestedIncludes[relation] = Object.keys(nested).length > 0 ? nested : true;
    });
    if (state.counts.size > 0) {
        hasSelection = true;
        for (const [count, selection] of state.counts){
            counts[count] = selection;
        }
        nestedIncludes._count = {
            select: counts
        };
    }
    if (state.mode === 'select') {
        for (const field of state.fields){
            hasSelection = true;
            nestedIncludes[field] = true;
        }
        return {
            ...state.query,
            select: nestedIncludes
        };
    }
    return hasSelection ? {
        ...state.query,
        include: nestedIncludes
    } : state.query;
}

//# sourceMappingURL=selections.js.map