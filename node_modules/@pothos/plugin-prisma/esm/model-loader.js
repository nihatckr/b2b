function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
import { createContextCache, PothosSchemaError } from '@pothos/core';
import { getDelegateFromModel, getModel } from './util/datamodel.js';
import { getClient } from './util/get-client.js';
import { cacheKey, setLoaderMappings } from './util/loader-map.js';
import { selectionStateFromInfo } from './util/map-query.js';
import { mergeSelection, selectionCompatible, selectionToQuery } from './util/selections.js';
export class ModelLoader {
    static forRef(ref, modelName, findUnique, builder) {
        return createContextCache((model) => new ModelLoader(model, builder, modelName, findUnique === null ? () => {
            throw new PothosSchemaError(`Missing findUnique for ${ref.name}`);
        } : findUnique !== null && findUnique !== void 0 ? findUnique : ModelLoader.getDefaultFindUnique(ref, modelName, builder)));
    }
    static getFindUnique(findBy) {
        if (typeof findBy === "string") {
            return (parent) => ({
                [findBy]: parent[findBy]
            });
        }
        const { fields, name: primaryKeyName } = findBy;
        return (parent) => {
            const primaryKey = {};
            for (const key of fields) {
                primaryKey[key] = parent[key];
            }
            return {
                [primaryKeyName !== null && primaryKeyName !== void 0 ? primaryKeyName : fields.join("_")]: primaryKey
            };
        };
    }
    static getDefaultFindBy(ref, modelName, builder) {
        const model = getModel(modelName, builder);
        const idField = model.fields.find((field) => field.isId);
        const uniqueField = model.fields.find((field) => field.isRequired && field.isUnique);
        const uniqueIndex = model.uniqueIndexes.find((idx) => idx.fields.every((field) => {
            var _model_fields_find;
            return (_model_fields_find = model.fields.find((f) => f.name === field)) === null || _model_fields_find === void 0 ? void 0 : _model_fields_find.isRequired;
        }));
        let findBy;
        if (model.primaryKey) {
            findBy = model.primaryKey;
        }
        else if (idField) {
            findBy = idField.name;
        }
        else if (uniqueField) {
            findBy = uniqueField.name;
        }
        else if (uniqueIndex) {
            findBy = uniqueIndex;
        }
        if (!findBy) {
            throw new PothosSchemaError(`Missing findUnique for ${ref.name}`);
        }
        return findBy;
    }
    static getDefaultFindUnique(ref, modelName, builder) {
        const findBy = ModelLoader.getDefaultFindBy(ref, modelName, builder);
        return ModelLoader.getFindUnique(findBy);
    }
    static getDefaultIDSelection(ref, modelName, builder) {
        const findBy = ModelLoader.getDefaultFindBy(ref, modelName, builder);
        if (typeof findBy === "string") {
            return {
                [findBy]: true
            };
        }
        const result = {};
        for (const field of findBy.fields) {
            result[field] = true;
        }
        return result;
    }
    static getCursorSelection(ref, modelName, cursor, builder) {
        const model = getModel(modelName, builder);
        const field = model.fields.find((field) => field.name === cursor);
        if (field) {
            return {
                [field.name]: true
            };
        }
        const index = [
            model.primaryKey,
            ...model.uniqueIndexes
        ].filter(Boolean).find((idx) => {
            var _idx_name;
            return ((_idx_name = idx.name) !== null && _idx_name !== void 0 ? _idx_name : idx.fields.join("_")) === cursor;
        });
        if (!index) {
            throw new PothosSchemaError(`Can't find "${cursor}" field or index for ${ref.name}`);
        }
        const selection = {};
        for (const column of index.fields) {
            selection[column] = true;
        }
        return selection;
    }
    static getFindUniqueForField(ref, modelName, fieldName, builder) {
        var _model_primaryKey, _model_primaryKey1;
        const model = getModel(modelName, builder);
        const uniqueIndex = model.uniqueIndexes.find((idx) => {
            var _idx_name;
            return ((_idx_name = idx.name) !== null && _idx_name !== void 0 ? _idx_name : idx.fields.join("_")) === fieldName;
        });
        let findBy;
        var _model_primaryKey_name;
        if (model.fields.some((field) => field.name === fieldName)) {
            findBy = fieldName;
        }
        else if (model.primaryKey && ((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === void 0 ? void 0 : _model_primaryKey.name) !== null && _model_primaryKey_name !== void 0 ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === void 0 ? void 0 : _model_primaryKey1.fields.join("_")) === fieldName) {
            findBy = model.primaryKey;
        }
        else if (uniqueIndex) {
            findBy = uniqueIndex;
        }
        if (!findBy) {
            throw new PothosSchemaError(`Unable to find field or index for ${fieldName} of ${ref.name}`);
        }
        return ModelLoader.getFindUnique(findBy);
    }
    getSelection(info) {
        const key = cacheKey(info.parentType.name, info.path);
        if (!this.queryCache.has(key)) {
            var _this_builder_options_prisma_skipDeferredFragments;
            const selection = selectionStateFromInfo(this.context, info, (_this_builder_options_prisma_skipDeferredFragments = this.builder.options.prisma.skipDeferredFragments) !== null && _this_builder_options_prisma_skipDeferredFragments !== void 0 ? _this_builder_options_prisma_skipDeferredFragments : true);
            this.queryCache.set(key, {
                selection,
                query: selectionToQuery(selection)
            });
        }
        return this.queryCache.get(key);
    }
    async loadSelection(info, model) {
        const { selection, query } = this.getSelection(info);
        const result = await this.stageQuery(selection, query, model);
        if (result) {
            const mappings = selection.mappings[info.path.key];
            if (mappings) {
                setLoaderMappings(this.context, info, mappings.mappings);
            }
        }
        return result;
    }
    async stageQuery(selection, query, model) {
        for (const entry of this.staged) {
            if (selectionCompatible(entry.state, query)) {
                mergeSelection(entry.state, query);
                if (!entry.models.has(model)) {
                    entry.models.set(model, createResolvablePromise());
                }
                return await entry.models.get(model).promise;
            }
        }
        return this.initLoad(selection, model);
    }
    initLoad(state, initialModel) {
        const delegate = getDelegateFromModel(getClient(this.builder, this.context), this.modelName);
        const models = new Map();
        const promise = createResolvablePromise();
        models.set(initialModel, promise);
        const entry = {
            models,
            state
        };
        this.staged.add(entry);
        const nextTick = createResolvablePromise();
        this.tick.then(() => {
            this.staged.delete(entry);
            for (const [model, { resolve, reject }] of entry.models) {
                if (delegate.findUniqueOrThrow) {
                    delegate.findUniqueOrThrow({
                        ...selectionToQuery(state),
                        where: {
                            ...this.findUnique(model, this.context)
                        }
                    }).then(resolve, reject);
                }
                else {
                    delegate.findUnique({
                        rejectOnNotFound: true,
                        ...selectionToQuery(state),
                        where: {
                            ...this.findUnique(model, this.context)
                        }
                    }).then(resolve, reject);
                }
            }
        });
        setTimeout(() => nextTick.resolve(), 0);
        this.tick = nextTick.promise;
        return promise.promise;
    }
    constructor(context, builder, modelName, findUnique) {
        _define_property(this, "context", void 0);
        _define_property(this, "builder", void 0);
        _define_property(this, "findUnique", void 0);
        _define_property(this, "modelName", void 0);
        _define_property(this, "queryCache", new Map());
        _define_property(this, "staged", new Set());
        _define_property(this, "tick", Promise.resolve());
        this.context = context;
        this.builder = builder;
        this.findUnique = findUnique;
        this.modelName = modelName;
    }
}
function createResolvablePromise() {
    let resolveFn;
    let rejectFn;
    const promise = new Promise((resolve, reject) => {
        resolveFn = resolve;
        rejectFn = reject;
    });
    return {
        promise,
        resolve: resolveFn,
        reject: rejectFn
    };
}
//# sourceMappingURL=model-loader.js.map
