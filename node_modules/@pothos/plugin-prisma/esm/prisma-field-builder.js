function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
import { isThenable, ObjectRef, RootFieldBuilder } from '@pothos/core';
import { Kind as GraphQLKind, getNamedType, isInterfaceType, isObjectType } from 'graphql';
import { ModelLoader } from './model-loader.js';
import { getCursorFormatter, getCursorParser, prismaCursorConnectionQuery, wrapConnectionResult } from './util/cursors.js';
import { getRefFromModel, getRelation } from './util/datamodel.js';
import { getFieldDescription } from './util/description.js';
// Workaround for FieldKind not being extended on Builder classes
const RootBuilder = RootFieldBuilder;
export class PrismaObjectFieldBuilder extends RootBuilder {
    relation(name, ...allArgs) {
        const [{ description, ...options } = {}] = allArgs;
        const relationField = getRelation(this.model, this.builder, name);
        var _options_type;
        const ref = (_options_type = options.type) !== null && _options_type !== void 0 ? _options_type : getRefFromModel(relationField.type, this.builder);
        const { query = {}, resolve, extensions, onNull, ...rest } = options;
        const relationSelect = (_args, _context, nestedQuery) => ({
            select: {
                [name]: nestedQuery(query)
            }
        });
        return this.field({
            ...rest,
            type: relationField.isList ? [
                ref
            ] : ref,
            description: getFieldDescription(this.model, this.builder, name, description),
            extensions: {
                ...extensions,
                pothosPrismaSelect: relationSelect,
                pothosPrismaLoaded: (value) => value[name] !== undefined,
                pothosPrismaFallback: resolve && ((q, parent, args, context, info) => resolve({
                    ...q,
                    ...typeof query === "function" ? query(args, context) : query
                }, parent, args, context, info))
            },
            resolve: (parent) => {
                const result = parent[name];
                if (typeof onNull === "function" && result == null) {
                    return onNull(parent, {}, {}, {});
                }
                return result;
            }
        });
    }
    relationCount(name, ...allArgs) {
        const [{ where, ...options } = {}] = allArgs;
        const countSelect = typeof where === "function" ? (args, context) => ({
            _count: {
                select: {
                    [name]: {
                        where: where(args, context)
                    }
                }
            }
        }) : {
            _count: {
                select: {
                    [name]: where ? {
                        where
                    } : true
                }
            }
        };
        return this.field({
            ...options,
            type: "Int",
            nullable: false,
            select: countSelect,
            resolve: (parent, _args, _context, _info) => {
                var _parent__count;
                return (_parent__count = parent._count) === null || _parent__count === void 0 ? void 0 : _parent__count[name];
            }
        });
    }
    variant(variant, ...allArgs) {
        const [{ isNull, nullable, ...options } = {}] = allArgs;
        const ref = typeof variant === "string" ? getRefFromModel(variant, this.builder) : variant;
        const selfSelect = (_args, _context, nestedQuery) => nestedQuery({});
        return this.field({
            ...options,
            type: ref,
            extensions: {
                ...options === null || options === void 0 ? void 0 : options.extensions,
                pothosPrismaSelect: selfSelect
            },
            nullable: nullable !== null && nullable !== void 0 ? nullable : !!isNull,
            resolve: isNull ? (parent, args, context, info) => {
                const parentIsNull = isNull(parent, args, context, info);
                if (parentIsNull) {
                    if (isThenable(parentIsNull)) {
                        return parentIsNull.then((resolved) => resolved ? null : parent);
                    }
                    return null;
                }
                return parent;
            } : (parent) => parent
        });
    }
    expose(name, ...args) {
        var _typeConfig_extensions;
        const [options = {}] = args;
        const typeConfig = this.builder.configStore.getTypeConfig(this.typename);
        const usingSelect = !!((_typeConfig_extensions = typeConfig.extensions) === null || _typeConfig_extensions === void 0 ? void 0 : _typeConfig_extensions.pothosPrismaSelect);
        return this.exposeField(name, {
            ...options,
            description: getFieldDescription(this.model, this.builder, name, options.description),
            extensions: {
                ...options.extensions,
                pothosPrismaVariant: name,
                pothosPrismaSelect: usingSelect && {
                    [name]: true
                }
            }
        });
    }
    createExpose(type) {
        return (name, ...args) => {
            const [options = {}] = args;
            return this.expose(name, {
                ...options,
                type
            });
        };
    }
    constructor(typename, builder, model, fieldMap, graphqlKind = "Object") {
        super(builder, "PrismaObject", graphqlKind), _define_property(this, "model", void 0), _define_property(this, "prismaFieldMap", void 0), _define_property(this, "exposeBoolean", this.createExpose("Boolean")), _define_property(this, "exposeFloat", this.createExpose("Float")), _define_property(this, "exposeInt", this.createExpose("Int")), _define_property(this, "exposeID", this.createExpose("ID")), _define_property(this, "exposeString", this.createExpose("String")), _define_property(this, "exposeBooleanList", this.createExpose([
            "Boolean"
        ])), _define_property(this, "exposeFloatList", this.createExpose([
            "Float"
        ])), _define_property(this, "exposeIntList", this.createExpose([
            "Int"
        ])), _define_property(this, "exposeIDList", this.createExpose([
            "ID"
        ])), _define_property(this, "exposeStringList", this.createExpose([
            "String"
        ])), _define_property(this, "withAuth", withAuth), _define_property(this, "relatedConnection", function relatedConnection(name, { maxSize = this.builder.options.prisma.maxConnectionSize, defaultSize = this.builder.options.prisma.defaultConnectionSize, cursor: cursorValue, query, resolve, extensions, totalCount, description, ...options }, connectionOptions = {}, edgeOptions = {}) {
            const relationField = getRelation(this.model, this.builder, name);
            var _options_type;
            const ref = (_options_type = options.type) !== null && _options_type !== void 0 ? _options_type : getRefFromModel(relationField.type, this.builder);
            let typeName;
            const formatCursor = getCursorFormatter(relationField.type, this.builder, cursorValue);
            const parseCursor = getCursorParser(relationField.type, this.builder, cursorValue);
            const getQuery = (args, ctx) => {
                const connectionQuery = prismaCursorConnectionQuery({
                    parseCursor,
                    ctx,
                    maxSize,
                    defaultSize,
                    args
                });
                var _ref;
                const { take = connectionQuery.take, skip = connectionQuery.skip, cursor = connectionQuery.cursor, ...fieldQuery } = (_ref = typeof query === "function" ? query(args, ctx) : query) !== null && _ref !== void 0 ? _ref : {};
                return {
                    ...fieldQuery,
                    ...connectionQuery,
                    take,
                    skip,
                    ...cursor ? {
                        cursor
                    } : {}
                };
            };
            const cursorSelection = ModelLoader.getCursorSelection(ref, relationField.type, cursorValue, this.builder);
            const relationSelect = (args, context, nestedQuery, getSelection) => {
                var _selection_selectionSet;
                typeName !== null && typeName !== void 0 ? typeName : typeName = this.builder.configStore.getTypeConfig(ref).name;
                const nested = nestedQuery(getQuery(args, context), {
                    getType: () => typeName,
                    paths: [
                        [
                            {
                                name: "nodes"
                            }
                        ],
                        [
                            {
                                name: "edges"
                            },
                            {
                                name: "node"
                            }
                        ]
                    ]
                });
                const selection = getSelection([]);
                const hasTotalCount = totalCount && !!getSelection([
                    "totalCount"
                ]);
                const selections = (_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === void 0 ? void 0 : _selection_selectionSet.selections.filter((sel) => !(sel.kind === GraphQLKind.FIELD && sel.name.value === "__typename"));
                const totalCountOnly = (selections === null || selections === void 0 ? void 0 : selections.length) === 1 && selections[0].kind === GraphQLKind.FIELD && selections[0].name.value === "totalCount" && hasTotalCount;
                const countSelect = this.builder.options.prisma.filterConnectionTotalCount !== false ? nested.where ? {
                    where: nested.where
                } : true : true;
                return {
                    select: {
                        ...hasTotalCount ? {
                            _count: {
                                select: {
                                    [name]: countSelect
                                }
                            }
                        } : {},
                        [name]: totalCountOnly ? undefined : (nested === null || nested === void 0 ? void 0 : nested.select) ? {
                            ...nested,
                            select: {
                                ...cursorSelection,
                                ...nested.select
                            }
                        } : nested
                    }
                };
            };
            const fieldRef = this.connection({
                ...options,
                description: getFieldDescription(this.model, this.builder, name, description),
                extensions: {
                    ...extensions,
                    pothosPrismaSelect: relationSelect,
                    pothosPrismaLoaded: (value, info) => {
                        const returnType = getNamedType(info.returnType);
                        const fields = isObjectType(returnType) || isInterfaceType(returnType) ? returnType.getFields() : {};
                        const selections = info.fieldNodes;
                        const totalCountOnly = selections.every((selection) => {
                            var _selection_selectionSet;
                            return (_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === void 0 ? void 0 : _selection_selectionSet.selections.every((s) => {
                                var _fields_s_name_value_extensions, _fields_s_name_value;
                                return s.kind === GraphQLKind.FIELD && (((_fields_s_name_value = fields[s.name.value]) === null || _fields_s_name_value === void 0 ? void 0 : (_fields_s_name_value_extensions = _fields_s_name_value.extensions) === null || _fields_s_name_value_extensions === void 0 ? void 0 : _fields_s_name_value_extensions.pothosPrismaTotalCount) || s.name.value === "__typename");
                            });
                        });
                        return totalCountOnly || value[name] !== undefined;
                    },
                    pothosPrismaFallback: resolve && ((q, parent, args, context, info) => Promise.resolve(resolve({
                        ...q,
                        ...getQuery(args, context)
                    }, parent, args, context, info)).then((result) => wrapConnectionResult(parent, result, args, q.take, formatCursor)))
                },
                type: ref,
                resolve: (parent, args, context) => {
                    var _parent__count;
                    const connectionQuery = getQuery(args, context);
                    var _parent_name;
                    return wrapConnectionResult(parent, (_parent_name = parent[name]) !== null && _parent_name !== void 0 ? _parent_name : [], args, connectionQuery.take, formatCursor, (_parent__count = parent._count) === null || _parent__count === void 0 ? void 0 : _parent__count[name]);
                }
            }, connectionOptions instanceof ObjectRef ? connectionOptions : {
                ...connectionOptions,
                fields: totalCount ? (t) => {
                    var _connectionOptions_fields;
                    return {
                        totalCount: t.int({
                            nullable: false,
                            extensions: {
                                pothosPrismaTotalCount: true
                            },
                            resolve: (parent, _args, _context) => parent.totalCount
                        }),
                        ...(_connectionOptions_fields = connectionOptions.fields) === null || _connectionOptions_fields === void 0 ? void 0 : _connectionOptions_fields.call(connectionOptions, t)
                    };
                } : connectionOptions.fields
            }, edgeOptions);
            return fieldRef;
        }), _define_property(this, "typename", void 0);
        this.model = model;
        this.prismaFieldMap = fieldMap;
        this.typename = typename;
        this.builder = builder;
    }
}
function addScopes(scopes, builder) {
    const originalCreateField = builder.createField;
    builder.createField = function createField(options) {
        return originalCreateField.call(this, {
            authScopes: scopes,
            ...options
        });
    };
    return builder;
}
function withAuth(scopes) {
    return addScopes(scopes, new PrismaObjectFieldBuilder(this.typename, this.builder, this.model, this.prismaFieldMap));
}
//# sourceMappingURL=prisma-field-builder.js.map
