var _builder_options_prisma, _builder_options_prisma1;
import { ModelLoader } from './model-loader.js';
import { getCursorFormatter, getCursorParser, prismaCursorConnectionQuery, wrapConnectionResult } from './util/cursors.js';
import { getRefFromModel } from './util/datamodel.js';
import { getDMMF } from './util/get-client.js';
import { getRelationMap } from './util/relation-map.js';
import { createState, mergeSelection, selectionToQuery } from './util/selections.js';
export const prismaModelKey = Symbol.for("Pothos.prismaModelKey");
export function prismaConnectionHelpers(builder, refOrType, { cursor, select, resolveNode, query, args: createArgs, maxSize = (_builder_options_prisma = builder.options.prisma) === null || _builder_options_prisma === void 0 ? void 0 : _builder_options_prisma.maxConnectionSize, defaultSize = (_builder_options_prisma1 = builder.options.prisma) === null || _builder_options_prisma1 === void 0 ? void 0 : _builder_options_prisma1.defaultConnectionSize }) {
    const modelName = typeof refOrType === "string" ? refOrType : refOrType.modelName;
    const ref = typeof refOrType === "string" ? getRefFromModel(modelName, builder) : refOrType;
    const formatCursor = getCursorFormatter(modelName, builder, cursor);
    const parseCursor = getCursorParser(modelName, builder, cursor);
    const cursorSelection = ModelLoader.getCursorSelection(ref, modelName, cursor, builder);
    const fieldMap = getRelationMap(getDMMF(builder)).get(modelName);
    function resolve(list, args, ctx, parent) {
        return wrapConnectionResult(parent, list, args, getQueryArgs(args, ctx).take, formatCursor, null, resolveNode !== null && resolveNode !== void 0 ? resolveNode : (edge) => edge);
    }
    function getQueryArgs(args, ctx) {
        return prismaCursorConnectionQuery({
            args,
            ctx,
            maxSize: typeof maxSize === "function" ? maxSize(args, ctx) : maxSize,
            defaultSize: typeof defaultSize === "function" ? defaultSize(args, ctx) : defaultSize,
            parseCursor
        });
    }
    function getQuery(args, ctx, nestedSelection) {
        const nestedSelect = select ? {
            select: select((sel) => nestedSelection(sel, [
                "edges",
                "node"
            ]), args, ctx)
        } : nestedSelection(true, [
            "edges",
            "node"
        ]);
        var _builder_options_prisma_skipDeferredFragments;
        const selectState = createState(fieldMap, "select", (_builder_options_prisma_skipDeferredFragments = builder.options.prisma.skipDeferredFragments) !== null && _builder_options_prisma_skipDeferredFragments !== void 0 ? _builder_options_prisma_skipDeferredFragments : true);
        mergeSelection(selectState, {
            select: cursorSelection
        });
        if (typeof nestedSelect === "object" && nestedSelect) {
            mergeSelection(selectState, nestedSelect);
        }
        const baseQuery = typeof query === "function" ? query(args, ctx) : query !== null && query !== void 0 ? query : {};
        return {
            ...baseQuery,
            ...getQueryArgs(args, ctx),
            ...selectionToQuery(selectState)
        };
    }
    const getArgs = () => createArgs ? builder.args(createArgs) : {};
    return {
        ref: typeof refOrType === "string" ? getRefFromModel(refOrType, builder) : refOrType,
        resolve,
        select: select !== null && select !== void 0 ? select : {},
        getQuery,
        getArgs
    };
}
//# sourceMappingURL=connection-helpers.js.map
