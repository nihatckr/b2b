import { decodeBase64, encodeBase64, PothosValidationError } from '@pothos/core';
import { getModel } from './datamodel.js';
import { extendWithUsage } from './usage.js';
const DEFAULT_MAX_SIZE = 100;
const DEFAULT_SIZE = 20;
export function formatCursorChunk(value) {
    if (value instanceof Date) {
        return `D:${String(Number(value))}`;
    }
    switch (typeof value) {
        case "number":
            return `N:${value}`;
        case "string":
            return `S:${value}`;
        case "bigint":
            return `I:${value}`;
        default:
            throw new PothosValidationError(`Unsupported cursor type ${typeof value}`);
    }
}
export function formatPrismaCursor(record, fields) {
    return cursorFormatter(fields)(record);
}
export function cursorFormatter(fields) {
    return (value) => {
        if (typeof fields === "string") {
            return encodeBase64(`GPC:${formatCursorChunk(value[fields])}`);
        }
        return encodeBase64(`GPC:J:${JSON.stringify(fields.map((name) => value[name]))}`);
    };
}
export function parsePrismaCursor(cursor) {
    if (typeof cursor !== "string") {
        throw new PothosValidationError("Cursor must be a string");
    }
    try {
        const decoded = decodeBase64(cursor);
        const [, type, value] = decoded.match(/^GPC:(\w):(.*)/);
        switch (type) {
            case "S":
                return value;
            case "N":
                return Number.parseInt(value, 10);
            case "D":
                return new Date(Number.parseInt(value, 10));
            case "J":
                return JSON.parse(value);
            case "I":
                return BigInt(value);
            default:
                throw new PothosValidationError(`Invalid cursor type ${type}`);
        }
    }
    catch {
        throw new PothosValidationError(`Invalid cursor: ${cursor}`);
    }
}
export function parseID(id, dataType) {
    if (!id) {
        return id;
    }
    switch (dataType) {
        case "String":
            return id;
        case "Int":
            return Number.parseInt(id, 10);
        case "BigInt":
            return BigInt(id);
        case "Boolean":
            return id !== "false";
        case "Float":
        case "Decimal":
            return Number.parseFloat(id);
        case "DateTime":
            return new Date(id);
        case "Json":
            return JSON.parse(id);
        case "Byte":
            return Buffer.from(id, "base64");
        default:
            return id;
    }
}
export function getDefaultIDSerializer(modelName, fieldName, builder) {
    var _model_primaryKey, _model_primaryKey1;
    const model = getModel(modelName, builder);
    const field = model.fields.find((f) => f.name === fieldName);
    if (field) {
        return (parent) => serializeID(parent[fieldName], field.type);
    }
    var _model_primaryKey_name;
    if (((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === void 0 ? void 0 : _model_primaryKey.name) !== null && _model_primaryKey_name !== void 0 ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === void 0 ? void 0 : _model_primaryKey1.fields.join("_")) === fieldName) {
        const fields = model.primaryKey.fields.map((n) => model.fields.find((f) => f.name === n));
        return (parent) => JSON.stringify(fields.map((f) => serializeID(parent[f.name], f.kind)));
    }
    const index = model.uniqueIndexes.find((idx) => {
        var _idx_name;
        return ((_idx_name = idx.name) !== null && _idx_name !== void 0 ? _idx_name : idx.fields.join("_")) === fieldName;
    });
    if (index) {
        const fields = index.fields.map((n) => model.fields.find((f) => f.name === n));
        return (parent) => JSON.stringify(fields.map((f) => serializeID(parent[f.name], f.kind)));
    }
    throw new PothosValidationError(`Unable to find ${fieldName} for model ${modelName}`);
}
export function getDefaultIDParser(modelName, fieldName, builder) {
    var _model_primaryKey, _model_primaryKey1;
    if (!fieldName) {
        throw new PothosValidationError("Missing field name");
    }
    const model = getModel(modelName, builder);
    const field = model.fields.find((f) => f.name === fieldName);
    if (field) {
        return (id) => parseID(id, field.type);
    }
    const index = model.uniqueIndexes.find((idx) => {
        var _idx_name;
        return ((_idx_name = idx.name) !== null && _idx_name !== void 0 ? _idx_name : idx.fields.join("_")) === fieldName;
    });
    let fields;
    var _model_primaryKey_name;
    if (((_model_primaryKey_name = (_model_primaryKey = model.primaryKey) === null || _model_primaryKey === void 0 ? void 0 : _model_primaryKey.name) !== null && _model_primaryKey_name !== void 0 ? _model_primaryKey_name : (_model_primaryKey1 = model.primaryKey) === null || _model_primaryKey1 === void 0 ? void 0 : _model_primaryKey1.fields.join("_")) === fieldName) {
        fields = model.primaryKey.fields.map((n) => model.fields.find((f) => f.name === n));
    }
    else if (index) {
        fields = index.fields.map((n) => model.fields.find((f) => f.name === n));
    }
    if (!fields) {
        throw new PothosValidationError(`Unable to find ${fieldName} for model ${modelName}`);
    }
    return (id) => {
        const parts = JSON.parse(id);
        if (!Array.isArray(parts)) {
            throw new PothosValidationError(`Invalid id received for ${fieldName} of ${modelName}`);
        }
        const result = {};
        for (let i = 0; i < fields.length; i += 1) {
            result[fields[i].name] = parseID(parts[i], fields[i].type);
        }
        return result;
    };
}
export function serializeID(id, dataType) {
    switch (dataType) {
        case "Json":
            return JSON.stringify(id);
        case "Byte":
            if (id instanceof Uint8Array) {
                return Buffer.from(id).toString("base64");
            }
            return id.toString("base64");
        default:
            return String(id);
    }
}
export function parseCompositeCursor(fields) {
    return (cursor) => {
        const parsed = parsePrismaCursor(cursor);
        if (!Array.isArray(parsed)) {
            throw new PothosValidationError(`Expected compound cursor to contain an array, but got ${parsed}`);
        }
        const record = {};
        fields.forEach((field, i) => {
            record[field] = parsed[i];
        });
        return record;
    };
}
export function prismaCursorConnectionQuery({ args, ctx, maxSize = DEFAULT_MAX_SIZE, defaultSize = DEFAULT_SIZE, parseCursor }) {
    const { before, after, first, last } = args;
    if (first != null && first < 0) {
        throw new PothosValidationError("Argument \"first\" must be a non-negative integer");
    }
    if (last != null && last < 0) {
        throw new PothosValidationError("Argument \"last\" must be a non-negative integer");
    }
    if (before && after) {
        throw new PothosValidationError("Arguments \"before\" and \"after\" are not supported at the same time");
    }
    if (before != null && first != null) {
        throw new PothosValidationError("Arguments \"before\" and \"first\" are not supported at the same time");
    }
    if (after != null && last != null) {
        throw new PothosValidationError("Arguments \"after\" and \"last\" are not supported at the same time");
    }
    const cursor = before !== null && before !== void 0 ? before : after;
    const maxSizeForConnection = typeof maxSize === "function" ? maxSize(args, ctx) : maxSize;
    const defaultSizeForConnection = typeof defaultSize === "function" ? defaultSize(args, ctx) : defaultSize;
    var _ref;
    let take = Math.min((_ref = first !== null && first !== void 0 ? first : last) !== null && _ref !== void 0 ? _ref : defaultSizeForConnection, maxSizeForConnection) + 1;
    if (before !== null && before !== void 0 ? before : last) {
        take = -take;
    }
    return cursor == null ? {
        take,
        skip: 0
    } : {
        cursor: parseCursor(cursor),
        take,
        skip: 1
    };
}
export function wrapConnectionResult(parent, results, args, take, cursor, totalCount, resolveNode) {
    var _edges_, _edges_1;
    const gotFullResults = results.length === Math.abs(take);
    const hasNextPage = args.before ? true : args.last ? false : gotFullResults;
    var _args_before;
    const hasPreviousPage = args.after ? true : ((_args_before = args.before) !== null && _args_before !== void 0 ? _args_before : args.last) ? gotFullResults : false;
    const nodes = gotFullResults ? results.slice(take < 0 ? 1 : 0, take < 0 ? results.length : -1) : results;
    const connection = {
        parent,
        args,
        totalCount,
        edges: [],
        pageInfo: {
            startCursor: null,
            endCursor: null,
            hasPreviousPage,
            hasNextPage
        }
    };
    const edges = nodes.map((value) => value == null ? null : resolveNode ? {
        connection,
        ...value,
        cursor: cursor(value),
        node: resolveNode(value)
    } : {
        connection,
        cursor: cursor(value),
        node: value
    });
    connection.edges = edges;
    var _edges__cursor;
    connection.pageInfo.startCursor = (_edges__cursor = (_edges_ = edges[0]) === null || _edges_ === void 0 ? void 0 : _edges_.cursor) !== null && _edges__cursor !== void 0 ? _edges__cursor : null;
    var _edges__cursor1;
    connection.pageInfo.endCursor = (_edges__cursor1 = (_edges_1 = edges[edges.length - 1]) === null || _edges_1 === void 0 ? void 0 : _edges_1.cursor) !== null && _edges__cursor1 !== void 0 ? _edges__cursor1 : null;
    return connection;
}
export async function resolvePrismaCursorConnection(options, cursor, resolve) {
    const query = prismaCursorConnectionQuery(options);
    const results = await resolve(extendWithUsage(options.query, query));
    if (!results) {
        return results;
    }
    return wrapConnectionResult(options.parent, results, options.args, query.take, cursor, options.totalCount);
}
export function getCursorFormatter(name, builder, cursor) {
    var _modelData_primaryKey, _modelData_primaryKey1;
    const modelData = getModel(name, builder);
    var _modelData_primaryKey_name;
    const primaryKey = (_modelData_primaryKey_name = (_modelData_primaryKey = modelData.primaryKey) === null || _modelData_primaryKey === void 0 ? void 0 : _modelData_primaryKey.name) !== null && _modelData_primaryKey_name !== void 0 ? _modelData_primaryKey_name : (_modelData_primaryKey1 = modelData.primaryKey) === null || _modelData_primaryKey1 === void 0 ? void 0 : _modelData_primaryKey1.fields.join("_");
    if (primaryKey === cursor) {
        return cursorFormatter(modelData.primaryKey.fields);
    }
    const uniqueIndex = modelData.uniqueIndexes.find((idx) => {
        var _idx_name;
        return ((_idx_name = idx.name) !== null && _idx_name !== void 0 ? _idx_name : idx.fields.join("_")) === cursor;
    });
    var _uniqueIndex_fields;
    return cursorFormatter((_uniqueIndex_fields = uniqueIndex === null || uniqueIndex === void 0 ? void 0 : uniqueIndex.fields) !== null && _uniqueIndex_fields !== void 0 ? _uniqueIndex_fields : cursor);
}
export function getCursorParser(name, builder, cursor) {
    var _modelData_primaryKey, _modelData_primaryKey1;
    const modelData = getModel(name, builder);
    var _modelData_primaryKey_name;
    const primaryKey = (_modelData_primaryKey_name = (_modelData_primaryKey = modelData.primaryKey) === null || _modelData_primaryKey === void 0 ? void 0 : _modelData_primaryKey.name) !== null && _modelData_primaryKey_name !== void 0 ? _modelData_primaryKey_name : (_modelData_primaryKey1 = modelData.primaryKey) === null || _modelData_primaryKey1 === void 0 ? void 0 : _modelData_primaryKey1.fields.join("_");
    let parser = parsePrismaCursor;
    if (primaryKey === cursor) {
        parser = parseCompositeCursor(modelData.primaryKey.fields);
    }
    else {
        const uniqueIndex = modelData.uniqueIndexes.find((idx) => {
            var _idx_name;
            return ((_idx_name = idx.name) !== null && _idx_name !== void 0 ? _idx_name : idx.fields.join("_")) === cursor;
        });
        if (uniqueIndex) {
            parser = parseCompositeCursor(uniqueIndex.fields);
        }
    }
    return (rawCursor) => ({
        [cursor]: parser(rawCursor)
    });
}
//# sourceMappingURL=cursors.js.map
