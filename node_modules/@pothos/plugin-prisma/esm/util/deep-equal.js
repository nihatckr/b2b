export function deepEqual(left, right, ignore) {
    if (left === right) {
        return true;
    }
    if (left && right && typeof left === "object" && typeof right === "object") {
        var _left_valueOf, _right_valueOf;
        if (Array.isArray(left)) {
            if (!Array.isArray(right)) {
                return false;
            }
            const { length } = left;
            if (right.length !== length) {
                return false;
            }
            for (let i = 0; i < length; i += 1) {
                if (!deepEqual(left[i], right[i])) {
                    return false;
                }
            }
            return true;
        }
        const lValue = (_left_valueOf = left.valueOf) === null || _left_valueOf === void 0 ? void 0 : _left_valueOf.call(left);
        const rValue = (_right_valueOf = right.valueOf) === null || _right_valueOf === void 0 ? void 0 : _right_valueOf.call(right);
        if ((lValue != null || rValue != null) && typeof lValue !== "object") {
            return lValue === rValue;
        }
        const keys = Object.keys(left);
        const keyLength = keys.length;
        if (keyLength !== Object.keys(right).length) {
            return false;
        }
        for (const key of keys) {
            if (ignore === null || ignore === void 0 ? void 0 : ignore.has(key)) {
                continue;
            }
            if (!deepEqual(left[key], right[key])) {
                return false;
            }
        }
        return true;
    }
    return false;
}
//# sourceMappingURL=deep-equal.js.map
