var _this_builder_options_prisma, _this_builder_options_prisma1;
import { isThenable, ObjectRef, PothosError, RootFieldBuilder } from '@pothos/core';
import { getNamedType, isInterfaceType, isObjectType, Kind } from 'graphql';
import { ModelLoader } from './model-loader.js';
import { getCursorFormatter, getCursorParser, resolvePrismaCursorConnection } from './util/cursors.js';
import { getRefFromModel } from './util/datamodel.js';
import { queryFromInfo } from './util/map-query.js';
import { isUsed } from './util/usage.js';
const fieldBuilderProto = RootFieldBuilder.prototype;
fieldBuilderProto.prismaField = function prismaField({ type, resolve, ...options }) {
    const modelOrRef = Array.isArray(type) ? type[0] : type;
    const typeRef = typeof modelOrRef === "string" ? getRefFromModel(modelOrRef, this.builder) : modelOrRef;
    const typeParam = Array.isArray(type) ? [
        typeRef
    ] : typeRef;
    return this.field({
        ...options,
        type: typeParam,
        resolve: (parent, args, context, info) => {
            var _this_builder_options_prisma, _this_builder_options_prisma1;
            const query = queryFromInfo({
                context,
                info,
                withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === void 0 ? void 0 : _this_builder_options_prisma.onUnusedQuery),
                skipDeferredFragments: (_this_builder_options_prisma1 = this.builder.options.prisma) === null || _this_builder_options_prisma1 === void 0 ? void 0 : _this_builder_options_prisma1.skipDeferredFragments
            });
            return checkIfQueryIsUsed(this.builder, query, info, resolve(query, parent, args, context, info));
        }
    });
};
fieldBuilderProto.prismaFieldWithInput = function prismaFieldWithInput({ type, resolve, ...options }) {
    const modelOrRef = Array.isArray(type) ? type[0] : type;
    const typeRef = typeof modelOrRef === "string" ? getRefFromModel(modelOrRef, this.builder) : modelOrRef;
    const typeParam = Array.isArray(type) ? [
        typeRef
    ] : typeRef;
    return this.fieldWithInput({
        ...options,
        type: typeParam,
        resolve: (parent, args, context, info) => {
            var _this_builder_options_prisma, _this_builder_options_prisma1;
            const query = queryFromInfo({
                context,
                info,
                withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === void 0 ? void 0 : _this_builder_options_prisma.onUnusedQuery),
                skipDeferredFragments: (_this_builder_options_prisma1 = this.builder.options.prisma) === null || _this_builder_options_prisma1 === void 0 ? void 0 : _this_builder_options_prisma1.skipDeferredFragments
            });
            return checkIfQueryIsUsed(this.builder, query, info, resolve(query, parent, args, context, info));
        }
    });
};
fieldBuilderProto.prismaConnection = function prismaConnection({ type, cursor, maxSize = (_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === void 0 ? void 0 : _this_builder_options_prisma.maxConnectionSize, defaultSize = (_this_builder_options_prisma1 = this.builder.options.prisma) === null || _this_builder_options_prisma1 === void 0 ? void 0 : _this_builder_options_prisma1.defaultConnectionSize, resolve, totalCount, ...options }, connectionOptions = {}, edgeOptions = {}) {
    var _this_builder_configStore_getTypeConfig_extensions;
    const ref = typeof type === "string" ? getRefFromModel(type, this.builder) : type;
    const typeName = this.builder.configStore.getTypeConfig(ref).name;
    const model = (_this_builder_configStore_getTypeConfig_extensions = this.builder.configStore.getTypeConfig(ref).extensions) === null || _this_builder_configStore_getTypeConfig_extensions === void 0 ? void 0 : _this_builder_configStore_getTypeConfig_extensions.pothosPrismaModel;
    const formatCursor = getCursorFormatter(model, this.builder, cursor);
    const parseCursor = getCursorParser(model, this.builder, cursor);
    const cursorSelection = ModelLoader.getCursorSelection(ref, model, cursor, this.builder);
    const fieldRef = this.connection({
        ...options,
        type: ref,
        resolve: (parent, args, context, info) => {
            var _this_builder_options_prisma, _this_builder_options_prisma1;
            const query = queryFromInfo({
                context,
                info,
                select: cursorSelection,
                paths: [
                    [
                        "nodes"
                    ],
                    [
                        "edges",
                        "node"
                    ]
                ],
                typeName,
                withUsageCheck: !!((_this_builder_options_prisma = this.builder.options.prisma) === null || _this_builder_options_prisma === void 0 ? void 0 : _this_builder_options_prisma.onUnusedQuery),
                skipDeferredFragments: (_this_builder_options_prisma1 = this.builder.options.prisma) === null || _this_builder_options_prisma1 === void 0 ? void 0 : _this_builder_options_prisma1.skipDeferredFragments
            });
            const returnType = getNamedType(info.returnType);
            const fields = isObjectType(returnType) || isInterfaceType(returnType) ? returnType.getFields() : {};
            const selections = info.fieldNodes;
            const totalCountOnly = selections.every((selection) => {
                var _selection_selectionSet;
                return (_selection_selectionSet = selection.selectionSet) === null || _selection_selectionSet === void 0 ? void 0 : _selection_selectionSet.selections.every((s) => {
                    var _fields_s_name_value_extensions, _fields_s_name_value;
                    return s.kind === Kind.FIELD && (((_fields_s_name_value = fields[s.name.value]) === null || _fields_s_name_value === void 0 ? void 0 : (_fields_s_name_value_extensions = _fields_s_name_value.extensions) === null || _fields_s_name_value_extensions === void 0 ? void 0 : _fields_s_name_value_extensions.pothosPrismaTotalCount) || s.name.value === "__typename");
                });
            });
            return resolvePrismaCursorConnection({
                parent,
                query,
                ctx: context,
                parseCursor,
                maxSize,
                defaultSize,
                args,
                totalCount: totalCount && (() => totalCount(parent, args, context, info))
            }, formatCursor, (q) => {
                if (totalCountOnly) {
                    return [];
                }
                return checkIfQueryIsUsed(this.builder, query, info, resolve(q, parent, args, context, info));
            });
        }
    }, connectionOptions instanceof ObjectRef ? connectionOptions : {
        ...connectionOptions,
        fields: totalCount ? (t) => {
            var _connectionOptions_fields;
            return {
                totalCount: t.int({
                    nullable: false,
                    extensions: {
                        pothosPrismaTotalCount: true
                    },
                    resolve: (parent) => {
                        var _parent_totalCount;
                        return (_parent_totalCount = parent.totalCount) === null || _parent_totalCount === void 0 ? void 0 : _parent_totalCount.call(parent);
                    }
                }),
                ...(_connectionOptions_fields = connectionOptions.fields) === null || _connectionOptions_fields === void 0 ? void 0 : _connectionOptions_fields.call(connectionOptions, t)
            };
        } : connectionOptions.fields,
        extensions: {
            ...connectionOptions === null || connectionOptions === void 0 ? void 0 : connectionOptions.extensions
        }
    }, edgeOptions);
    return fieldRef;
};
function checkIfQueryIsUsed(builder, query, info, result) {
    const { onUnusedQuery } = builder.options.prisma || {};
    if (!onUnusedQuery) {
        return result;
    }
    if (isThenable(result)) {
        return result.then((resolved) => {
            if (!isUsed(query)) {
                onUnused();
            }
            return resolved;
        });
    }
    if (!isUsed(query)) {
        onUnused();
    }
    return result;
    function onUnused() {
        if (typeof onUnusedQuery === "function") {
            onUnusedQuery(info);
            return;
        }
        const message = `Prisma query was unused in resolver for ${info.parentType.name}.${info.fieldName}`;
        if (onUnusedQuery === "error") {
            throw new PothosError(message);
        }
        if (onUnusedQuery === "warn") {
            console.warn(message);
        }
    }
}
//# sourceMappingURL=field-builder.js.map
