function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
import { completeValue, reduceMaybeAsync } from '../utils/index.js';
import { BasePlugin } from './plugin.js';
export class MergedPlugins extends BasePlugin {
    onTypeConfig(typeConfig) {
        return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onTypeConfig(config), typeConfig);
    }
    onInputFieldConfig(fieldConfig) {
        return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onInputFieldConfig(config), fieldConfig);
    }
    onOutputFieldConfig(fieldConfig) {
        return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onOutputFieldConfig(config), fieldConfig);
    }
    onEnumValueConfig(valueConfig) {
        return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onEnumValueConfig(config), valueConfig);
    }
    beforeBuild() {
        for (const plugin of this.plugins) {
            plugin.beforeBuild();
        }
    }
    afterBuild(schema) {
        return this.plugins.reduceRight((nextSchema, plugin) => plugin.afterBuild(nextSchema), schema);
    }
    wrapResolve(resolve, fieldConfig) {
        const wrapped = this.plugins.reduceRight((nextResolve, plugin) => plugin.wrapResolve(nextResolve, fieldConfig), resolve);
        if (!fieldConfig.argMappers.length) {
            return this.wrapArgMappers(wrapped, fieldConfig);
        }
        const argMappers = fieldConfig.argMappers;
        return this.wrapArgMappers((parent, args, context, info) => {
            const mappedArgs = reduceMaybeAsync(argMappers, args, (acc, argMapper) => {
                return argMapper(acc, context, info);
            });
            return completeValue(mappedArgs, (mappedArgs) => wrapped(parent, mappedArgs, context, info));
        }, fieldConfig);
    }
    wrapSubscribe(subscribe, fieldConfig) {
        const wrapped = this.plugins.reduceRight((nextSubscribe, plugin) => plugin.wrapSubscribe(nextSubscribe, fieldConfig), subscribe);
        if (!wrapped || !fieldConfig.argMappers.length) {
            return this.wrapArgMappers(wrapped, fieldConfig);
        }
        const argMappers = fieldConfig.argMappers;
        return this.wrapArgMappers((parent, args, context, info) => {
            const mappedArgs = reduceMaybeAsync(argMappers, args, (acc, argMapper) => {
                return argMapper(acc, context, info);
            });
            return completeValue(mappedArgs, (mappedArgs) => wrapped(parent, mappedArgs, context, info));
        }, fieldConfig);
    }
    wrapArgMappers(resolver, fieldConfig) {
        return this.plugins.reduceRight((nextResolveType, plugin) => plugin.wrapArgMappers(nextResolveType, fieldConfig), resolver);
    }
    wrapResolveType(resolveType, typeConfig) {
        return this.plugins.reduceRight((nextResolveType, plugin) => plugin.wrapResolveType(nextResolveType, typeConfig), resolveType);
    }
    wrapIsTypeOf(isTypeOf, typeConfig) {
        return this.plugins.reduceRight((nextResolveType, plugin) => plugin.wrapIsTypeOf(nextResolveType, typeConfig), isTypeOf);
    }
    constructor(buildCache, plugins) {
        super(buildCache, "PothosMergedPlugin"), _define_property(this, "plugins", void 0);
        this.plugins = plugins;
    }
}
//# sourceMappingURL=merge-plugins.js.map
