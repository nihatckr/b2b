import { type DirectiveNode, type FieldNode, type GraphQLDirective, type GraphQLField } from 'graphql';
import { type InputType, type InputTypeParam, type MaybePromise, type OutputType, type PartialResolveInfo, type SchemaTypes, type TypeParam } from '../types';
export * from './base64';
export * from './context-cache';
export * from './enums';
export * from './input';
export * from './params';
export * from './sort-classes';
export declare function assertNever(value: never): never;
export declare function assertArray(value: unknown): value is unknown[];
export declare function isThenable(value: unknown): value is PromiseLike<unknown>;
export declare function verifyRef(ref: unknown): void;
export declare function verifyInterfaces(interfaces: unknown): void;
export declare function brandWithType<Types extends SchemaTypes>(val: unknown, type: OutputType<Types>): void;
export declare function getTypeBrand(val: unknown): OutputType<SchemaTypes> | null;
export declare function unwrapListParam<Types extends SchemaTypes>(param: InputTypeParam<Types> | TypeParam<Types>): InputType<Types> | OutputType<Types>;
export declare function unwrapOutputListParam<Types extends SchemaTypes>(param: TypeParam<Types>): OutputType<Types>;
export declare function unwrapInputListParam<Types extends SchemaTypes>(param: InputTypeParam<Types>): InputType<Types>;
/**
 * Helper for allowing plugins to fulfill the return of the `next` resolver, without paying the cost of the
 * Promise if not required.
 */
export declare function completeValue<T, R>(valOrPromise: PromiseLike<T> | T, onSuccess: (completedVal: T) => PromiseLike<R> | R, onError?: (errVal: unknown) => PromiseLike<R> | R): Promise<Awaited<R>> | Awaited<R>;
export declare function getMappedArgumentValues(def: GraphQLDirective | GraphQLField<unknown, unknown>, node: DirectiveNode | FieldNode, context: object, info: PartialResolveInfo): MaybePromise<{
    [argument: string]: unknown;
}>;
export declare function reduceMaybeAsync<T, R>(items: T[], initialValue: R, fn: (value: R, item: T, i: number) => MaybePromise<R>): MaybePromise<R>;
//# sourceMappingURL=index.d.ts.map