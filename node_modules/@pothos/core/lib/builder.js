"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SchemaBuilder", {
    enumerable: true,
    get: function() {
        return SchemaBuilder;
    }
});
const _graphql = require("graphql");
const _buildcache = require("./build-cache");
const _configstore = require("./config-store");
const _errors = require("./errors");
const _input = require("./fieldUtils/input");
const _interface = require("./fieldUtils/interface");
const _mutation = require("./fieldUtils/mutation");
const _object = require("./fieldUtils/object");
const _query = require("./fieldUtils/query");
const _subscription = require("./fieldUtils/subscription");
const _base = require("./refs/base");
const _enum = require("./refs/enum");
const _inputobject = require("./refs/input-object");
const _interface1 = require("./refs/interface");
const _mutation1 = require("./refs/mutation");
const _object1 = require("./refs/object");
const _query1 = require("./refs/query");
const _scalar = require("./refs/scalar");
const _subscription1 = require("./refs/subscription");
const _union = require("./refs/union");
const _utils = require("./utils");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class SchemaBuilder {
    static registerPlugin(name, plugin, normalizeOptions) {
        if (!SchemaBuilder.allowPluginReRegistration && SchemaBuilder.plugins[name]) {
            throw new _errors.PothosError(`Received multiple implementations for plugin ${name}`);
        }
        SchemaBuilder.plugins[name] = plugin;
        if (normalizeOptions) {
            SchemaBuilder.optionNormalizers.set(name, normalizeOptions);
        }
    }
    objectType(param, options, fields) {
        (0, _utils.verifyRef)(param);
        (0, _utils.verifyInterfaces)(options.interfaces);
        var _options_name;
        const name = typeof param === 'string' ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
        const ref = param instanceof _base.BaseTypeRef ? param : new _object1.ObjectRef(name);
        ref.updateConfig({
            kind: 'Object',
            graphqlKind: 'Object',
            name,
            interfaces: [],
            description: options.description,
            extensions: options.extensions,
            isTypeOf: options.isTypeOf,
            pothosOptions: options
        });
        if (options.interfaces) {
            ref.addInterfaces(options.interfaces);
        }
        if (ref !== param && typeof param !== 'string') {
            this.configStore.associateParamWithRef(param, ref);
        }
        if (fields) {
            ref.addFields(()=>fields(new _object.ObjectFieldBuilder(this)));
        }
        if (options.fields) {
            ref.addFields(()=>{
                const t = new _object.ObjectFieldBuilder(this);
                return options.fields(t);
            });
        }
        this.configStore.addTypeRef(ref);
        return ref;
    }
    objectFields(param, fields) {
        (0, _utils.verifyRef)(param);
        this.configStore.addFields(param, ()=>fields(new _object.ObjectFieldBuilder(this)));
    }
    objectField(param, fieldName, field) {
        (0, _utils.verifyRef)(param);
        this.configStore.addFields(param, ()=>({
                [fieldName]: field(new _object.ObjectFieldBuilder(this))
            }));
    }
    queryType(...args) {
        const [options = {}, fields] = args;
        var _options_name;
        this.queryRef.updateConfig({
            kind: 'Query',
            graphqlKind: 'Object',
            name: (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : 'Query',
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        });
        if (options.name) {
            this.queryRef.name = options.name;
        }
        this.configStore.addTypeRef(this.queryRef);
        if (fields) {
            this.queryRef.addFields(()=>fields(new _query.QueryFieldBuilder(this)));
        }
        if (options.fields) {
            this.queryRef.addFields(()=>options.fields(new _query.QueryFieldBuilder(this)));
        }
        return this.queryRef;
    }
    queryFields(fields) {
        this.configStore.addFields(this.queryRef, ()=>fields(new _query.QueryFieldBuilder(this)));
    }
    queryField(name, field) {
        this.configStore.addFields(this.queryRef, ()=>({
                [name]: field(new _query.QueryFieldBuilder(this))
            }));
    }
    mutationType(...args) {
        const [options = {}, fields] = args;
        var _options_name;
        this.mutationRef.updateConfig({
            kind: 'Mutation',
            graphqlKind: 'Object',
            name: (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : 'Mutation',
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        });
        this.configStore.addTypeRef(this.mutationRef);
        if (options.name) {
            this.mutationRef.name = options.name;
        }
        if (fields) {
            this.configStore.addFields(this.mutationRef, ()=>fields(new _mutation.MutationFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields(this.mutationRef, ()=>options.fields(new _mutation.MutationFieldBuilder(this)));
        }
        return this.mutationRef;
    }
    mutationFields(fields) {
        this.configStore.addFields(this.mutationRef, ()=>fields(new _mutation.MutationFieldBuilder(this)));
    }
    mutationField(name, field) {
        this.configStore.addFields(this.mutationRef, ()=>({
                [name]: field(new _mutation.MutationFieldBuilder(this))
            }));
    }
    subscriptionType(...args) {
        const [options = {}, fields] = args;
        var _options_name;
        this.subscriptionRef.updateConfig({
            kind: 'Subscription',
            graphqlKind: 'Object',
            name: (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : 'Subscription',
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        });
        this.configStore.addTypeRef(this.subscriptionRef);
        if (options.name) {
            this.subscriptionRef.name = options.name;
        }
        if (fields) {
            this.configStore.addFields(this.subscriptionRef, ()=>fields(new _subscription.SubscriptionFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields(this.subscriptionRef, ()=>options.fields(new _subscription.SubscriptionFieldBuilder(this)));
        }
        return this.subscriptionRef;
    }
    subscriptionFields(fields) {
        this.configStore.addFields(this.subscriptionRef, ()=>fields(new _subscription.SubscriptionFieldBuilder(this)));
    }
    subscriptionField(name, field) {
        this.configStore.addFields(this.subscriptionRef, ()=>({
                [name]: field(new _subscription.SubscriptionFieldBuilder(this))
            }));
    }
    args(fields) {
        return fields(new _input.InputFieldBuilder(this, 'Arg'));
    }
    interfaceType(param, options, fields) {
        (0, _utils.verifyRef)(param);
        (0, _utils.verifyInterfaces)(options.interfaces);
        var _options_name;
        const name = typeof param === 'string' ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
        const ref = param instanceof _base.BaseTypeRef ? param : new _interface1.InterfaceRef(name);
        const typename = ref.name;
        ref.updateConfig({
            kind: 'Interface',
            graphqlKind: 'Interface',
            name: typename,
            interfaces: [],
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions,
            resolveType: options.resolveType
        });
        this.configStore.addTypeRef(ref);
        if (options.interfaces) {
            ref.addInterfaces(options.interfaces);
        }
        if (ref !== param && typeof param !== 'string') {
            this.configStore.associateParamWithRef(param, ref);
        }
        if (fields) {
            this.configStore.addFields(ref, ()=>fields(new _interface.InterfaceFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields(ref, ()=>options.fields(new _interface.InterfaceFieldBuilder(this)));
        }
        return ref;
    }
    interfaceFields(ref, fields) {
        (0, _utils.verifyRef)(ref);
        this.configStore.addFields(ref, ()=>fields(new _interface.InterfaceFieldBuilder(this)));
    }
    interfaceField(ref, fieldName, field) {
        (0, _utils.verifyRef)(ref);
        this.configStore.addFields(ref, ()=>({
                [fieldName]: field(new _interface.InterfaceFieldBuilder(this))
            }));
    }
    unionType(name, options) {
        const ref = new _union.UnionRef(name, {
            kind: 'Union',
            graphqlKind: 'Union',
            name,
            types: [],
            description: options.description,
            resolveType: options.resolveType,
            pothosOptions: options,
            extensions: options.extensions
        });
        if (Array.isArray(options.types)) {
            for (const type of options.types){
                (0, _utils.verifyRef)(type);
            }
        }
        this.configStore.addTypeRef(ref);
        ref.addTypes(options.types);
        return ref;
    }
    enumType(param, options) {
        (0, _utils.verifyRef)(param);
        const name = typeof param === 'string' ? param : options.name;
        const values = typeof param === 'object' ? (0, _utils.valuesFromEnum)(param, options === null || options === void 0 ? void 0 : options.values) : (0, _utils.normalizeEnumValues)(options.values);
        const ref = new _enum.EnumRef(name, {
            kind: 'Enum',
            graphqlKind: 'Enum',
            name,
            values,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        });
        this.configStore.addTypeRef(ref);
        if (typeof param !== 'string') {
            this.configStore.associateParamWithRef(param, ref);
        }
        return ref;
    }
    scalarType(name, options) {
        const ref = new _scalar.ScalarRef(name, {
            kind: 'Scalar',
            graphqlKind: 'Scalar',
            name,
            description: options.description,
            parseLiteral: options.parseLiteral,
            parseValue: options.parseValue,
            serialize: options.serialize,
            pothosOptions: options,
            extensions: options.extensions
        });
        this.configStore.addTypeRef(ref);
        return ref;
    }
    addScalarType(name, scalar, ...args) {
        const [options = {}] = args;
        const config = scalar.toConfig();
        return this.scalarType(name, {
            ...config,
            ...options,
            extensions: {
                ...config.extensions,
                ...options.extensions
            }
        });
    }
    inputType(param, options) {
        (0, _utils.verifyRef)(param);
        const name = typeof param === 'string' ? param : param.name;
        const ref = typeof param === 'string' ? new _inputobject.InputObjectRef(name) : param;
        ref.updateConfig({
            kind: 'InputObject',
            graphqlKind: 'InputObject',
            name,
            isOneOf: options.isOneOf,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        });
        this.configStore.addTypeRef(ref);
        if (param !== ref && typeof param !== 'string') {
            this.configStore.associateParamWithRef(param, ref);
        }
        this.configStore.addInputFields(ref, ()=>options.fields(new _input.InputFieldBuilder(this, 'InputObject')));
        return ref;
    }
    inputRef(name) {
        return new _inputobject.ImplementableInputObjectRef(this, name);
    }
    objectRef(name) {
        return new _object1.ImplementableObjectRef(this, name);
    }
    interfaceRef(name) {
        return new _interface1.ImplementableInterfaceRef(this, name);
    }
    toSchema(...args) {
        const [options = {}] = args;
        const { directives, extensions } = options;
        const scalars = [
            _graphql.GraphQLID,
            _graphql.GraphQLInt,
            _graphql.GraphQLFloat,
            _graphql.GraphQLString,
            _graphql.GraphQLBoolean
        ];
        for (const scalar of scalars){
            if (!this.configStore.hasImplementation(scalar.name)) {
                this.addScalarType(scalar.name, scalar);
            }
        }
        const buildCache = new _buildcache.BuildCache(this, options);
        buildCache.plugin.beforeBuild();
        buildCache.buildAll();
        const builtTypes = [
            ...buildCache.types.values()
        ];
        const queryName = this.configStore.hasConfig(this.queryRef) ? this.configStore.getTypeConfig(this.queryRef).name : 'Query';
        const mutationName = this.configStore.hasConfig(this.mutationRef) ? this.configStore.getTypeConfig(this.mutationRef).name : 'Mutation';
        const subscriptionName = this.configStore.hasConfig(this.subscriptionRef) ? this.configStore.getTypeConfig(this.subscriptionRef).name : 'Subscription';
        const schema = new _graphql.GraphQLSchema({
            query: buildCache.types.get(queryName),
            mutation: buildCache.types.get(mutationName),
            subscription: buildCache.types.get(subscriptionName),
            extensions: extensions !== null && extensions !== void 0 ? extensions : {},
            directives: directives,
            types: builtTypes
        });
        const processedSchema = buildCache.plugin.afterBuild(schema);
        return options.sortSchema === false ? processedSchema : (0, _graphql.lexicographicSortSchema)(processedSchema);
    }
    constructor(options){
        _define_property(this, "$inferSchemaTypes", void 0);
        _define_property(this, "queryRef", new _query1.QueryRef('Query'));
        _define_property(this, "mutationRef", new _mutation1.MutationRef('Mutation'));
        _define_property(this, "subscriptionRef", new _subscription1.SubscriptionRef('Subscription'));
        _define_property(this, "configStore", void 0);
        _define_property(this, "options", void 0);
        _define_property(this, "defaultFieldNullability", void 0);
        _define_property(this, "defaultInputFieldRequiredness", void 0);
        this.options = [
            ...SchemaBuilder.optionNormalizers.values()
        ].reduce((opts, normalize)=>{
            if (options.defaults && typeof normalize[options.defaults] === 'function') {
                // biome-ignore lint/performance/noAccumulatingSpread: this is fine
                return Object.assign(opts, normalize[options.defaults](opts));
            }
            return opts;
        }, options);
        this.configStore = new _configstore.ConfigStore(this);
        var _options_defaultFieldNullability;
        this.defaultFieldNullability = (_options_defaultFieldNullability = options.defaultFieldNullability) !== null && _options_defaultFieldNullability !== void 0 ? _options_defaultFieldNullability : options.defaults !== 'v3';
        var _options_defaultInputFieldRequiredness;
        this.defaultInputFieldRequiredness = (_options_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _options_defaultInputFieldRequiredness !== void 0 ? _options_defaultInputFieldRequiredness : false;
    }
}
_define_property(SchemaBuilder, "plugins", {});
_define_property(SchemaBuilder, "optionNormalizers", new Map());
_define_property(SchemaBuilder, "allowPluginReRegistration", false);

//# sourceMappingURL=builder.js.map