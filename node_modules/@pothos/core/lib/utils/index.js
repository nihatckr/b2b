"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get assertArray () {
        return assertArray;
    },
    get assertNever () {
        return assertNever;
    },
    get brandWithType () {
        return brandWithType;
    },
    get completeValue () {
        return completeValue;
    },
    get getMappedArgumentValues () {
        return getMappedArgumentValues;
    },
    get getTypeBrand () {
        return getTypeBrand;
    },
    get isThenable () {
        return isThenable;
    },
    get reduceMaybeAsync () {
        return reduceMaybeAsync;
    },
    get unwrapInputListParam () {
        return unwrapInputListParam;
    },
    get unwrapListParam () {
        return unwrapListParam;
    },
    get unwrapOutputListParam () {
        return unwrapOutputListParam;
    },
    get verifyInterfaces () {
        return verifyInterfaces;
    },
    get verifyRef () {
        return verifyRef;
    }
});
const _graphql = require("graphql");
const _errors = require("../errors");
const _inputlist = require("../refs/input-list");
const _list = require("../refs/list");
const _types = require("../types");
_export_star(require("./base64"), exports);
_export_star(require("./context-cache"), exports);
_export_star(require("./enums"), exports);
_export_star(require("./input"), exports);
_export_star(require("./params"), exports);
_export_star(require("./sort-classes"), exports);
function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
            Object.defineProperty(to, k, {
                enumerable: true,
                get: function() {
                    return from[k];
                }
            });
        }
    });
    return from;
}
function assertNever(value) {
    throw new TypeError(`Unexpected value: ${value}`);
}
function assertArray(value) {
    if (!Array.isArray(value)) {
        throw new _errors.PothosValidationError('List resolvers must return arrays');
    }
    return true;
}
function isThenable(value) {
    return !!(value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function');
}
function verifyRef(ref) {
    if (ref === undefined) {
        throw new _errors.PothosSchemaError(`Received undefined as a type ref.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
    }
}
function verifyInterfaces(interfaces) {
    if (!interfaces || typeof interfaces === 'function') {
        return;
    }
    if (!Array.isArray(interfaces)) {
        throw new _errors.PothosSchemaError('interfaces must be an array or function');
    }
    for (const iface of interfaces){
        if (iface === undefined) {
            throw new _errors.PothosSchemaError(`Received undefined in list of interfaces.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
        }
    }
}
function brandWithType(val, type) {
    if (typeof val !== 'object' || val === null) {
        return;
    }
    Object.defineProperty(val, _types.typeBrandKey, {
        enumerable: false,
        value: type
    });
}
function getTypeBrand(val) {
    if (typeof val === 'object' && val !== null && _types.typeBrandKey in val) {
        return val[_types.typeBrandKey];
    }
    return null;
}
function unwrapListParam(param) {
    if (Array.isArray(param)) {
        return unwrapListParam(param[0]);
    }
    if (param instanceof _list.ListRef || param instanceof _inputlist.InputListRef) {
        return unwrapListParam(param.listType);
    }
    return param;
}
function unwrapOutputListParam(param) {
    if (Array.isArray(param)) {
        return unwrapOutputListParam(param[0]);
    }
    if (param instanceof _list.ListRef) {
        return unwrapOutputListParam(param.listType);
    }
    return param;
}
function unwrapInputListParam(param) {
    if (Array.isArray(param)) {
        return unwrapInputListParam(param[0]);
    }
    if (param instanceof _inputlist.InputListRef) {
        return unwrapInputListParam(param.listType);
    }
    return param;
}
function completeValue(valOrPromise, onSuccess, onError) {
    if (isThenable(valOrPromise)) {
        return Promise.resolve(valOrPromise).then(onSuccess, onError);
    }
    // No need to handle onError, this should just be a try/catch inside the `onSuccess` block
    const result = onSuccess(valOrPromise);
    // If the result of the synchronous call is a promise like, convert to a promise
    // for consistency
    if (isThenable(result)) {
        return Promise.resolve(result);
    }
    return result;
}
function getMappedArgumentValues(def, node, context, info) {
    var _def_extensions;
    const args = (0, _graphql.getArgumentValues)(def, node, info.variableValues);
    const mappers = (_def_extensions = def.extensions) === null || _def_extensions === void 0 ? void 0 : _def_extensions.pothosArgMappers;
    if (mappers && mappers.length > 0) {
        return reduceMaybeAsync(mappers, args, (acc, argMapper)=>argMapper(acc, context, info));
    }
    return args;
}
function reduceMaybeAsync(items, initialValue, fn) {
    function next(value, i) {
        if (i === items.length) {
            return value;
        }
        return completeValue(fn(value, items[i], i), (result)=>{
            return result === null ? null : next(result, i + 1);
        });
    }
    return next(initialValue, 0);
}

//# sourceMappingURL=index.js.map